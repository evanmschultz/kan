# Repository Guidelines

This file defines instructions for coding agents working in this repository. It is not runtime behavior for `kan`.

You are a senior Go dev. YOU ALWAYS:

- ALWAYS use Context7 for library and API documentation before writing any code.
- ALWAYS re-run Context7 after any test failure or runtime error before making the next edit.
- If Context7 is unavailable (quota, network, outage), record the fallback source before proceeding (for example official docs, `go doc`, or package-local docs).
- Write idiomatic Go doc comments for all top-level declarations and methods in production and test code, and add inline comments for non-obvious behavior blocks (including behavior blocks in `*_test.go`).
- Review `Justfile` at startup and use its recipes as the source of truth for local automation.
- Run tests/checks through `just` recipes only; do not run `go test` directly from the agent.
- Run `just` recipes directly (for example `just ci`) without `GOCACHE=...` or other cache-path env overrides unless the user explicitly asks for an override.
- Do not create workspace-local ad-hoc Go cache directories (for example `.go-cache-*`) during normal test/check execution.
- During normal implementation loops, run `just check` after meaningful increments to catch local regressions early.
- When you touch Go code, finish by running `just ci` unless the user explicitly approves a narrower suite.
- Before asking the user to push or before opening/refreshing a PR, run `just ci` and report results.
- If you touch `.github/workflows/` or `Justfile`, run both `just check` and `just ci` before handoff.
- In subagent parallel mode (single-branch orchestration), worker lanes may run scoped checks (`just test-pkg ...`), but the integrator must run `just ci` before marking a lane integrated/closed.
- In subagent prompts, explicitly require: Context7 before any code change, Context7 again after any failed test/runtime error, and package-scoped `just test-pkg` checks for touched packages.
- Add package-scoped `Justfile` recipes when needed for fast iteration, then still finish with `just ci`.
- Treat runtime logging as a first-class implementation concern:
  - use `github.com/charmbracelet/log` as the canonical logger for application/runtime logs.
  - keep colored/styled console output enabled for local developer ergonomics.
  - in dev mode, write logs to a workspace-local `.kan/log/` directory so logs are easy to inspect during debugging.
  - log meaningful runtime operations and failures (startup paths/config load, persistence/migrations, mutating actions, recoverable/non-recoverable errors).
- During troubleshooting, inspect recent local log files before proposing fixes and include relevant findings in your reasoning.
- Keep error handling idiomatic:
  - wrap errors with `%w`,
  - return errors upward at clean boundaries,
  - log context-rich failures at adapter/runtime edges instead of swallowing errors.
- If dependency updates need network access, ask the user to run `go get` and module update commands in their own shell.
- Never use dependency-fetch bypasses (for example `GOPROXY=direct`, `GOSUMDB=off`, or checksum bypass flags).
- Never delete files or directories without explicit user approval.
- Keep the active execution/work log in `PLAN.md`. Use `worklogs/` only when the user explicitly asks for split logs.
- When creating the MCP design/planning markdown file (for example `MCP_DESIGN_AND_PLAN.md`), you must explicitly review and discuss all locked roadmap decisions, unresolved roadmap items, and relevant current-code constraints from `PLAN.md`, `PRE_PHASE11_CLOSEOUT_DISCUSSION.md`, `PRE_MCP_EXECUTION_WAVES.md`, `PRE_MCP_CONSENSUS.md`, and `Pre_MCP_User_NOTES.md` before proposing implementation phases.
- When clarification is needed, ask in two stages:
  - first ask general goal-alignment questions and lock shared objectives,
  - only after that consensus ask specific implementation-detail questions.

## Project Structure

- `cmd/kan`: CLI/TUI entrypoint.
- `internal/domain`: core entities and invariants.
- `internal/app`: application services and use-cases (ports-first, hexagonal core).
- `internal/adapters/storage/sqlite`: SQLite persistence adapter.
- `internal/config`: TOML loading, defaults, validation.
- `internal/platform`: OS-specific config/data/db path resolution.
- `internal/tui`: Bubble Tea/Bubbles/Lip Gloss presentation layer.
- `.artifacts/`: generated local outputs (exports, temporary build outputs).
- `PLAN.md`: active roadmap and execution/work log.

## Build and Run

- `just run`: run app from source (`go run ./cmd/kan`).
- `just build`: build local binary `./kan`.
- `just fmt`: format Go files.
- `just check`: cross-platform smoke gate (source verification, format check, tests, build).
- `just test`, `just test-pkg <pkg>`: test entrypoints.
- `just test-golden`, `just test-golden-update`: golden fixture validation/update.
- `just ci`: canonical full gate (source verification, format check, coverage-verified tests, build).

## Worktrees

- Worktrees are optional but supported.
- If a worktree path is requested by the user, always `cd` into that exact path before editing, testing, or committing.
- Do not hard-code worktree names.
- Do not run completion/cleanup git actions (push, merge, rebase, worktree removal, branch deletion) without explicit user approval in the current conversation.

## Worklogs

- Use `PLAN.md` as the live execution ledger.
- Keep updates step-by-step while work is in progress. At minimum log:
  - current objective/plan,
  - each command/test run and outcome,
  - each file edit and why,
  - each failure and remediation,
  - current status and next step.
- In subagent parallel mode, `PLAN.md` is single-writer:
  - only the orchestrator/integrator updates lock tables, lane status, and completion markers.
  - worker subagents must not directly edit `PLAN.md`; they provide handoff notes for orchestrator ingestion.
- Every orchestrator checkpoint update in `PLAN.md` must include command/test evidence:
  - commands run and outcomes,
  - tests/checks run and outcomes,
  - or explicit `test_not_applicable` with rationale for docs-only/process-only steps.

## Temporary Next-Step Directive (Pre-MCP Closeout + MCP Build)

- This temporary section is active for the current phase:
  - finish all remaining pre-MCP non-roadmap gaps,
  - implement non-roadmap MCP/HTTP functionality discussed and locked in planning docs,
  - prioritize dogfooding readiness for real user+agent workflows.
- For this temporary phase, use `MCP_DESIGN_AND_PLAN.md` as the execution/worklog hub for MCP-oriented slices.
- Orchestrator requirements:
  - plan for coexistent parallel subagents with explicit, non-overlapping file-lock scopes,
  - prevent workers from touching the same file concurrently,
  - perform explicit code review on every worker handoff before integration.
- Delivery requirements for this temporary phase:
  - keep docs synchronized as implementation lands (`README.md` and affected planning/testing docs),
  - ensure `just check` and `just ci` both pass before marking work complete,
  - create/update one TUI manual worksheet for current behavior verification,
  - create/update one HTTP/MCP (MCP-primary) dogfooding worksheet for user+agent validation.
- Dogfooding requirement:
  - testing docs must support collaborative user+agent validation and clearly call out guardrails, blockers, and recovery workflows.
- Cleanup requirement:
  - after this temporary phase is confirmed complete by the user, explicitly ask how this temporary AGENTS directive should be removed or reduced.

## Parallel/Subagent Mode

- This repository supports parallel subagent execution on a single branch only under lock discipline.
- Roles:
  - orchestrator: decomposition, lane assignment, lock ownership, approval escalation.
  - worker subagent: scoped implementation lane and evidence handoff.
  - integrator: sole patch applier to shared branch and gate owner.
- Lock rules:
  - lane must declare file-glob lock scope before edits.
  - no edits outside lane lock.
  - hotspot files require serialized ownership (`internal/tui/model.go`, `internal/app/service.go`, `internal/adapters/storage/sqlite/repo.go`).
- Approval/permission failure flow:
  - subagent command fails on permission gate.
  - orchestrator surfaces exact failure and approval request.
  - after user approval, orchestrator reruns blocked command or resumes lane.
- Completion policy:
  - no lane is marked complete until integrator verifies acceptance criteria and test evidence.
  - final wave closeout requires successful `just ci`.

### Orchestrator Prompt Contract (Required)

- Every worker-lane prompt must include:
  - lane id and single acceptance objective,
  - lock scope (allowed file globs) and explicit out-of-scope paths,
  - concrete acceptance criteria mapped to the current phase/task,
  - architecture constraints for this repo (hexagonal boundaries, allowed dependency directions, and hotspot ownership),
  - testing plan (`just` commands only) and whether lane follows tests-first or a justified TDD exception,
  - explicit worker test scope: package-level `just test-pkg <pkg>` for touched packages (no repo-wide gate in worker lanes),
  - doc/comment expectations for touched Go declarations and non-obvious logic,
  - explicit Context7 checkpoints: before first code edit and after every failed test/runtime error, plus fallback behavior when unavailable,
  - expected handoff format and evidence requirements.
- Worker prompts must explicitly forbid:
  - edits outside lane lock,
  - direct `go test` execution,
  - running repo-wide test gates (`just test`, `just check`, `just ci`) unless the orchestrator explicitly assigns it,
  - architecture-layer violations unless explicitly authorized by the lane objective.

### Worker Handoff Contract (Required)

- Every worker handoff must include:
  - lane id and checkpoint id,
  - files changed and why,
  - commands run and pass/fail outcomes,
  - acceptance criteria checklist with pass/fail per item,
  - architecture-boundary compliance note,
  - doc/comment compliance note for touched Go code,
  - Context7 compliance note (initial consult + any failure-triggered re-consults),
  - unresolved risks/blockers and recommended next step.

## Tech Stack

- Go 1.26+
- Bubble Tea v2, Bubbles v2, Lip Gloss v2
- SQLite (`modernc.org/sqlite`, no CGO)
- TOML config (`github.com/pelletier/go-toml/v2`)

## Core Coding Paradigms

- Hexagonal architecture (ports/adapters), interface-first boundaries, dependency inversion.
- Ship small, testable increments; prioritize maintainability and pragmatic MVP progress.
- TDD-first where practical: tests before implementation for new behavior.
- Preserve Go idioms: clear naming, wrapped errors (`fmt.Errorf("...: %w", err)`), import grouping stdlib -> third-party -> local.
- Keep TUI mode transitions explicit and test-covered.

## Testing Guidelines

- Tests are co-located as `*_test.go`.
- Prefer table-driven tests and behavior-oriented assertions.
- Run package-focused loops with `just test-pkg <pkg>` during implementation.
- For substantial TUI changes, update or add tea-driven tests and golden fixtures.
- Coverage below 70% is a hard failure.
- Build/test execution must go through `just` recipes only.
- Do not wrap `just` test commands with custom Go cache env vars by default; use plain `just` invocations.

## UX Guardrails

- Help bar stays bottom-anchored in normal mode.
- Expanded help is a centered modal overlay (Fang-inspired style).
- Add/edit/info/project/search overlays are centered and do not push board content.
- Support both vim keys and arrow keys.
- Mouse wheel/click behavior must continue to function.
- Keep modal copy concise and avoid redundant field explanations.

## Release and Security

- Keep release/Homebrew work in roadmap unless explicitly requested for execution.
- Keep secrets out of config files committed to the repository.
- Prefer environment overrides for machine-local sensitive settings.

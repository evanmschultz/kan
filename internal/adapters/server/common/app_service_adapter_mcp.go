package common

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/hylla/hakoll/internal/app"
	"github.com/hylla/hakoll/internal/domain"
)

// GetBootstrapGuide returns summary-first onboarding guidance for empty-instance flows.
func (a *AppServiceAdapter) GetBootstrapGuide(_ context.Context) (BootstrapGuide, error) {
	if a == nil || a.service == nil {
		return BootstrapGuide{}, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	return BootstrapGuide{
		Mode:      "bootstrap_required",
		Summary:   "No project context exists yet. Start by creating your first project and then capture state.",
		WhatKanIs: "Kan is a strict task/state planner with level-scoped work (project|branch|phase|subphase|task|subtask), guardrailed mutations, and summary-first recovery context.",
		Capabilities: []string{
			"Level-scoped capture_state for summary-first recovery",
			"Task graph operations across branch/phase/subphase/task/subtask scopes",
			"Attention/blocker signaling with user-action visibility",
			"Kind catalog and template-driven child/checklist auto-actions",
			"Capability lease issuance and guardrailed non-user mutations",
		},
		NextSteps: []string{
			"Create a project with koll.create_project",
			"Create level-scoped work items with koll.create_task",
			"Call koll.capture_state to reorient and continue safely",
		},
		Recommended: []string{
			"koll.list_projects",
			"koll.create_project",
			"koll.create_task",
			"koll.capture_state",
		},
		RoadmapNotice: "Import/export transport-closure and advanced conflict tooling remain roadmap-only for this wave.",
	}, nil
}

// ListProjects returns project rows from app-level APIs.
func (a *AppServiceAdapter) ListProjects(ctx context.Context, includeArchived bool) ([]domain.Project, error) {
	if a == nil || a.service == nil {
		return nil, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	projects, err := a.service.ListProjects(ctx, includeArchived)
	if err != nil {
		return nil, mapAppError("list projects", err)
	}
	return projects, nil
}

// CreateProject creates one project with optional kind and metadata.
func (a *AppServiceAdapter) CreateProject(ctx context.Context, in CreateProjectRequest) (domain.Project, error) {
	if a == nil || a.service == nil {
		return domain.Project{}, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	ctx, actorType, err := withMutationGuardContext(ctx, in.Actor)
	if err != nil {
		return domain.Project{}, err
	}
	project, err := a.service.CreateProjectWithMetadata(ctx, app.CreateProjectInput{
		Name:        strings.TrimSpace(in.Name),
		Description: strings.TrimSpace(in.Description),
		Kind:        domain.KindID(strings.TrimSpace(in.Kind)),
		Metadata:    in.Metadata,
		UpdatedBy:   strings.TrimSpace(in.Actor.AgentName),
		UpdatedType: actorType,
	})
	if err != nil {
		return domain.Project{}, mapAppError("create project", err)
	}
	return project, nil
}

// UpdateProject updates one project.
func (a *AppServiceAdapter) UpdateProject(ctx context.Context, in UpdateProjectRequest) (domain.Project, error) {
	if a == nil || a.service == nil {
		return domain.Project{}, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	ctx, actorType, err := withMutationGuardContext(ctx, in.Actor)
	if err != nil {
		return domain.Project{}, err
	}
	project, err := a.service.UpdateProject(ctx, app.UpdateProjectInput{
		ProjectID:   strings.TrimSpace(in.ProjectID),
		Name:        strings.TrimSpace(in.Name),
		Description: strings.TrimSpace(in.Description),
		Kind:        domain.KindID(strings.TrimSpace(in.Kind)),
		Metadata:    in.Metadata,
		UpdatedBy:   strings.TrimSpace(in.Actor.AgentName),
		UpdatedType: actorType,
	})
	if err != nil {
		return domain.Project{}, mapAppError("update project", err)
	}
	return project, nil
}

// ListTasks returns tasks for one project with deterministic ordering from app-level APIs.
func (a *AppServiceAdapter) ListTasks(ctx context.Context, projectID string, includeArchived bool) ([]domain.Task, error) {
	if a == nil || a.service == nil {
		return nil, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	tasks, err := a.service.ListTasks(ctx, strings.TrimSpace(projectID), includeArchived)
	if err != nil {
		return nil, mapAppError("list tasks", err)
	}
	return tasks, nil
}

// CreateTask creates one level-scoped task/work item.
func (a *AppServiceAdapter) CreateTask(ctx context.Context, in CreateTaskRequest) (domain.Task, error) {
	if a == nil || a.service == nil {
		return domain.Task{}, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	dueAt, err := parseOptionalRFC3339(in.DueAt)
	if err != nil {
		return domain.Task{}, err
	}
	ctx, actorType, err := withMutationGuardContext(ctx, in.Actor)
	if err != nil {
		return domain.Task{}, err
	}
	task, err := a.service.CreateTask(ctx, app.CreateTaskInput{
		ProjectID:      strings.TrimSpace(in.ProjectID),
		ParentID:       strings.TrimSpace(in.ParentID),
		Kind:           domain.WorkKind(strings.TrimSpace(in.Kind)),
		Scope:          domain.KindAppliesTo(strings.TrimSpace(in.Scope)),
		ColumnID:       strings.TrimSpace(in.ColumnID),
		Title:          strings.TrimSpace(in.Title),
		Description:    strings.TrimSpace(in.Description),
		Priority:       domain.Priority(strings.TrimSpace(strings.ToLower(in.Priority))),
		DueAt:          dueAt,
		Labels:         append([]string(nil), in.Labels...),
		Metadata:       in.Metadata,
		CreatedByActor: strings.TrimSpace(in.Actor.AgentName),
		UpdatedByActor: strings.TrimSpace(in.Actor.AgentName),
		UpdatedByType:  actorType,
	})
	if err != nil {
		return domain.Task{}, mapAppError("create task", err)
	}
	return task, nil
}

// UpdateTask updates one task/work-item row.
func (a *AppServiceAdapter) UpdateTask(ctx context.Context, in UpdateTaskRequest) (domain.Task, error) {
	if a == nil || a.service == nil {
		return domain.Task{}, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	dueAt, err := parseOptionalRFC3339(in.DueAt)
	if err != nil {
		return domain.Task{}, err
	}
	ctx, actorType, err := withMutationGuardContext(ctx, in.Actor)
	if err != nil {
		return domain.Task{}, err
	}
	task, err := a.service.UpdateTask(ctx, app.UpdateTaskInput{
		TaskID:      strings.TrimSpace(in.TaskID),
		Title:       strings.TrimSpace(in.Title),
		Description: strings.TrimSpace(in.Description),
		Priority:    domain.Priority(strings.TrimSpace(strings.ToLower(in.Priority))),
		DueAt:       dueAt,
		Labels:      append([]string(nil), in.Labels...),
		Metadata:    in.Metadata,
		UpdatedBy:   strings.TrimSpace(in.Actor.AgentName),
		UpdatedType: actorType,
	})
	if err != nil {
		return domain.Task{}, mapAppError("update task", err)
	}
	return task, nil
}

// MoveTask moves one task to a target column/position.
func (a *AppServiceAdapter) MoveTask(ctx context.Context, in MoveTaskRequest) (domain.Task, error) {
	if a == nil || a.service == nil {
		return domain.Task{}, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	ctx, _, err := withMutationGuardContext(ctx, in.Actor)
	if err != nil {
		return domain.Task{}, err
	}
	task, err := a.service.MoveTask(ctx, strings.TrimSpace(in.TaskID), strings.TrimSpace(in.ToColumnID), in.Position)
	if err != nil {
		return domain.Task{}, mapAppError("move task", err)
	}
	return task, nil
}

// DeleteTask applies archive/hard delete behavior for one task.
func (a *AppServiceAdapter) DeleteTask(ctx context.Context, in DeleteTaskRequest) error {
	if a == nil || a.service == nil {
		return fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	ctx, _, err := withMutationGuardContext(ctx, in.Actor)
	if err != nil {
		return err
	}
	if err := a.service.DeleteTask(ctx, strings.TrimSpace(in.TaskID), app.DeleteMode(strings.TrimSpace(in.Mode))); err != nil {
		return mapAppError("delete task", err)
	}
	return nil
}

// RestoreTask restores one archived task.
func (a *AppServiceAdapter) RestoreTask(ctx context.Context, in RestoreTaskRequest) (domain.Task, error) {
	if a == nil || a.service == nil {
		return domain.Task{}, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	ctx, _, err := withMutationGuardContext(ctx, in.Actor)
	if err != nil {
		return domain.Task{}, err
	}
	task, err := a.service.RestoreTask(ctx, strings.TrimSpace(in.TaskID))
	if err != nil {
		return domain.Task{}, mapAppError("restore task", err)
	}
	return task, nil
}

// ReparentTask changes the parent relationship for one task.
func (a *AppServiceAdapter) ReparentTask(ctx context.Context, in ReparentTaskRequest) (domain.Task, error) {
	if a == nil || a.service == nil {
		return domain.Task{}, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	ctx, _, err := withMutationGuardContext(ctx, in.Actor)
	if err != nil {
		return domain.Task{}, err
	}
	task, err := a.service.ReparentTask(ctx, strings.TrimSpace(in.TaskID), strings.TrimSpace(in.ParentID))
	if err != nil {
		return domain.Task{}, mapAppError("reparent task", err)
	}
	return task, nil
}

// ListChildTasks lists children for one parent task.
func (a *AppServiceAdapter) ListChildTasks(ctx context.Context, projectID, parentID string, includeArchived bool) ([]domain.Task, error) {
	if a == nil || a.service == nil {
		return nil, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	tasks, err := a.service.ListChildTasks(ctx, strings.TrimSpace(projectID), strings.TrimSpace(parentID), includeArchived)
	if err != nil {
		return nil, mapAppError("list child tasks", err)
	}
	return tasks, nil
}

// SearchTasks runs a scoped or cross-project search query.
func (a *AppServiceAdapter) SearchTasks(ctx context.Context, in SearchTasksRequest) ([]SearchTaskMatch, error) {
	if a == nil || a.service == nil {
		return nil, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	matches, err := a.service.SearchTaskMatches(ctx, app.SearchTasksFilter{
		ProjectID:       strings.TrimSpace(in.ProjectID),
		Query:           strings.TrimSpace(in.Query),
		CrossProject:    in.CrossProject,
		IncludeArchived: in.IncludeArchived,
		States:          append([]string(nil), in.States...),
	})
	if err != nil {
		return nil, mapAppError("search task matches", err)
	}
	out := make([]SearchTaskMatch, 0, len(matches))
	for _, match := range matches {
		out = append(out, SearchTaskMatch{
			Project: match.Project,
			Task:    match.Task,
			StateID: match.StateID,
		})
	}
	return out, nil
}

// ListProjectChangeEvents returns recent change events for one project.
func (a *AppServiceAdapter) ListProjectChangeEvents(ctx context.Context, projectID string, limit int) ([]domain.ChangeEvent, error) {
	if a == nil || a.service == nil {
		return nil, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	events, err := a.service.ListProjectChangeEvents(ctx, strings.TrimSpace(projectID), limit)
	if err != nil {
		return nil, mapAppError("list project change events", err)
	}
	return events, nil
}

// GetProjectDependencyRollup returns dependency counts for one project.
func (a *AppServiceAdapter) GetProjectDependencyRollup(ctx context.Context, projectID string) (domain.DependencyRollup, error) {
	if a == nil || a.service == nil {
		return domain.DependencyRollup{}, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	rollup, err := a.service.GetProjectDependencyRollup(ctx, strings.TrimSpace(projectID))
	if err != nil {
		return domain.DependencyRollup{}, mapAppError("get project dependency rollup", err)
	}
	return rollup, nil
}

// ListKindDefinitions lists kind catalog entries.
func (a *AppServiceAdapter) ListKindDefinitions(ctx context.Context, includeArchived bool) ([]domain.KindDefinition, error) {
	if a == nil || a.service == nil {
		return nil, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	kinds, err := a.service.ListKindDefinitions(ctx, includeArchived)
	if err != nil {
		return nil, mapAppError("list kind definitions", err)
	}
	return kinds, nil
}

// UpsertKindDefinition creates or updates one kind catalog entry.
func (a *AppServiceAdapter) UpsertKindDefinition(ctx context.Context, in UpsertKindDefinitionRequest) (domain.KindDefinition, error) {
	if a == nil || a.service == nil {
		return domain.KindDefinition{}, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	kind, err := a.service.UpsertKindDefinition(ctx, app.CreateKindDefinitionInput{
		ID:                  domain.KindID(strings.TrimSpace(in.ID)),
		DisplayName:         strings.TrimSpace(in.DisplayName),
		DescriptionMarkdown: strings.TrimSpace(in.DescriptionMarkdown),
		AppliesTo:           toKindAppliesToList(in.AppliesTo),
		AllowedParentScopes: toKindAppliesToList(in.AllowedParentScopes),
		PayloadSchemaJSON:   strings.TrimSpace(in.PayloadSchemaJSON),
		Template:            in.Template,
	})
	if err != nil {
		return domain.KindDefinition{}, mapAppError("upsert kind definition", err)
	}
	return kind, nil
}

// SetProjectAllowedKinds updates a project's kind allowlist.
func (a *AppServiceAdapter) SetProjectAllowedKinds(ctx context.Context, in SetProjectAllowedKindsRequest) error {
	if a == nil || a.service == nil {
		return fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	if err := a.service.SetProjectAllowedKinds(ctx, app.SetProjectAllowedKindsInput{
		ProjectID: strings.TrimSpace(in.ProjectID),
		KindIDs:   toKindIDList(in.KindIDs),
	}); err != nil {
		return mapAppError("set project allowed kinds", err)
	}
	return nil
}

// ListProjectAllowedKinds lists canonical kind ids in one project's allowlist.
func (a *AppServiceAdapter) ListProjectAllowedKinds(ctx context.Context, projectID string) ([]string, error) {
	if a == nil || a.service == nil {
		return nil, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	kindIDs, err := a.service.ListProjectAllowedKinds(ctx, strings.TrimSpace(projectID))
	if err != nil {
		return nil, mapAppError("list project allowed kinds", err)
	}
	out := make([]string, 0, len(kindIDs))
	for _, kindID := range kindIDs {
		out = append(out, string(kindID))
	}
	return out, nil
}

// IssueCapabilityLease issues one scope-bound capability lease.
func (a *AppServiceAdapter) IssueCapabilityLease(ctx context.Context, in IssueCapabilityLeaseRequest) (domain.CapabilityLease, error) {
	if a == nil || a.service == nil {
		return domain.CapabilityLease{}, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	lease, err := a.service.IssueCapabilityLease(ctx, app.IssueCapabilityLeaseInput{
		ProjectID:                 strings.TrimSpace(in.ProjectID),
		ScopeType:                 domain.CapabilityScopeType(strings.TrimSpace(in.ScopeType)),
		ScopeID:                   strings.TrimSpace(in.ScopeID),
		Role:                      domain.CapabilityRole(strings.TrimSpace(in.Role)),
		AgentName:                 strings.TrimSpace(in.AgentName),
		AgentInstanceID:           strings.TrimSpace(in.AgentInstanceID),
		ParentInstanceID:          strings.TrimSpace(in.ParentInstanceID),
		AllowEqualScopeDelegation: in.AllowEqualScopeDelegation,
		RequestedTTL:              durationFromSeconds(in.RequestedTTLSeconds),
		OverrideToken:             strings.TrimSpace(in.OverrideToken),
	})
	if err != nil {
		return domain.CapabilityLease{}, mapAppError("issue capability lease", err)
	}
	return lease, nil
}

// HeartbeatCapabilityLease records one heartbeat against an active lease.
func (a *AppServiceAdapter) HeartbeatCapabilityLease(ctx context.Context, in HeartbeatCapabilityLeaseRequest) (domain.CapabilityLease, error) {
	if a == nil || a.service == nil {
		return domain.CapabilityLease{}, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	lease, err := a.service.HeartbeatCapabilityLease(ctx, app.HeartbeatCapabilityLeaseInput{
		AgentInstanceID: strings.TrimSpace(in.AgentInstanceID),
		LeaseToken:      strings.TrimSpace(in.LeaseToken),
	})
	if err != nil {
		return domain.CapabilityLease{}, mapAppError("heartbeat capability lease", err)
	}
	return lease, nil
}

// RenewCapabilityLease extends one lease expiry.
func (a *AppServiceAdapter) RenewCapabilityLease(ctx context.Context, in RenewCapabilityLeaseRequest) (domain.CapabilityLease, error) {
	if a == nil || a.service == nil {
		return domain.CapabilityLease{}, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	lease, err := a.service.RenewCapabilityLease(ctx, app.RenewCapabilityLeaseInput{
		AgentInstanceID: strings.TrimSpace(in.AgentInstanceID),
		LeaseToken:      strings.TrimSpace(in.LeaseToken),
		TTL:             durationFromSeconds(in.TTLSeconds),
	})
	if err != nil {
		return domain.CapabilityLease{}, mapAppError("renew capability lease", err)
	}
	return lease, nil
}

// RevokeCapabilityLease revokes one lease by instance id.
func (a *AppServiceAdapter) RevokeCapabilityLease(ctx context.Context, in RevokeCapabilityLeaseRequest) (domain.CapabilityLease, error) {
	if a == nil || a.service == nil {
		return domain.CapabilityLease{}, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	lease, err := a.service.RevokeCapabilityLease(ctx, app.RevokeCapabilityLeaseInput{
		AgentInstanceID: strings.TrimSpace(in.AgentInstanceID),
		Reason:          strings.TrimSpace(in.Reason),
	})
	if err != nil {
		return domain.CapabilityLease{}, mapAppError("revoke capability lease", err)
	}
	return lease, nil
}

// RevokeAllCapabilityLeases revokes all matching leases for one scope tuple.
func (a *AppServiceAdapter) RevokeAllCapabilityLeases(ctx context.Context, in RevokeAllCapabilityLeasesRequest) error {
	if a == nil || a.service == nil {
		return fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	if err := a.service.RevokeAllCapabilityLeases(ctx, app.RevokeAllCapabilityLeasesInput{
		ProjectID: strings.TrimSpace(in.ProjectID),
		ScopeType: domain.CapabilityScopeType(strings.TrimSpace(in.ScopeType)),
		ScopeID:   strings.TrimSpace(in.ScopeID),
		Reason:    strings.TrimSpace(in.Reason),
	}); err != nil {
		return mapAppError("revoke all capability leases", err)
	}
	return nil
}

// CreateComment creates one markdown comment for a concrete target.
func (a *AppServiceAdapter) CreateComment(ctx context.Context, in CreateCommentRequest) (domain.Comment, error) {
	if a == nil || a.service == nil {
		return domain.Comment{}, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	ctx, actorType, err := withMutationGuardContext(ctx, in.Actor)
	if err != nil {
		return domain.Comment{}, err
	}
	comment, err := a.service.CreateComment(ctx, app.CreateCommentInput{
		ProjectID:    strings.TrimSpace(in.ProjectID),
		TargetType:   domain.CommentTargetType(strings.TrimSpace(in.TargetType)),
		TargetID:     strings.TrimSpace(in.TargetID),
		BodyMarkdown: strings.TrimSpace(in.BodyMarkdown),
		ActorType:    actorType,
		AuthorName:   strings.TrimSpace(in.Actor.AgentName),
	})
	if err != nil {
		return domain.Comment{}, mapAppError("create comment", err)
	}
	return comment, nil
}

// ListCommentsByTarget lists comments for one concrete target.
func (a *AppServiceAdapter) ListCommentsByTarget(ctx context.Context, in ListCommentsByTargetRequest) ([]domain.Comment, error) {
	if a == nil || a.service == nil {
		return nil, fmt.Errorf("app service adapter is not configured: %w", ErrInvalidCaptureStateRequest)
	}
	comments, err := a.service.ListCommentsByTarget(ctx, app.ListCommentsByTargetInput{
		ProjectID:  strings.TrimSpace(in.ProjectID),
		TargetType: domain.CommentTargetType(strings.TrimSpace(in.TargetType)),
		TargetID:   strings.TrimSpace(in.TargetID),
	})
	if err != nil {
		return nil, mapAppError("list comments by target", err)
	}
	return comments, nil
}

// parseOptionalRFC3339 parses one optional RFC3339 timestamp string.
func parseOptionalRFC3339(raw string) (*time.Time, error) {
	raw = strings.TrimSpace(raw)
	if raw == "" {
		return nil, nil
	}
	ts, err := time.Parse(time.RFC3339, raw)
	if err != nil {
		return nil, fmt.Errorf("due_at must be RFC3339: %w", ErrInvalidCaptureStateRequest)
	}
	utc := ts.UTC()
	return &utc, nil
}

// withMutationGuardContext validates actor tuple semantics and optionally attaches lease guard context.
func withMutationGuardContext(ctx context.Context, actor ActorLeaseTuple) (context.Context, domain.ActorType, error) {
	if ctx == nil {
		ctx = context.Background()
	}
	requestedActorType := strings.TrimSpace(strings.ToLower(actor.ActorType))
	actorType := normalizeActorType(actor.ActorType)
	if !isValidActorType(actorType) {
		return nil, "", fmt.Errorf("actor_type %q is unsupported: %w", actor.ActorType, ErrInvalidCaptureStateRequest)
	}

	agentName := strings.TrimSpace(actor.AgentName)
	agentInstanceID := strings.TrimSpace(actor.AgentInstanceID)
	leaseToken := strings.TrimSpace(actor.LeaseToken)
	overrideToken := strings.TrimSpace(actor.OverrideToken)
	hasGuardTuple := agentInstanceID != "" || leaseToken != "" || overrideToken != ""
	if hasGuardTuple && actorType == domain.ActorTypeUser {
		// Preserve backward compatibility for guard-aware callers that omitted actor_type.
		if requestedActorType == "" {
			actorType = domain.ActorTypeAgent
		} else {
			return nil, "", fmt.Errorf("actor_type=user cannot be used with guarded mutation tuple: %w", ErrInvalidCaptureStateRequest)
		}
	}

	if actorType != domain.ActorTypeUser || hasGuardTuple {
		if agentName == "" || agentInstanceID == "" || leaseToken == "" {
			return nil, "", fmt.Errorf("agent_name, agent_instance_id, and lease_token are required for non-user or guarded mutations: %w", ErrInvalidCaptureStateRequest)
		}
		ctx = app.WithMutationGuard(ctx, app.MutationGuard{
			AgentName:       agentName,
			AgentInstanceID: agentInstanceID,
			LeaseToken:      leaseToken,
			OverrideToken:   overrideToken,
		})
	}
	if agentName != "" {
		ctx = app.WithMutationActor(ctx, app.MutationActor{
			ActorID:   agentName,
			ActorType: actorType,
		})
	}
	return ctx, actorType, nil
}

// normalizeActorType canonicalizes actor type values and defaults to user.
func normalizeActorType(actorType string) domain.ActorType {
	normalized := domain.ActorType(strings.TrimSpace(strings.ToLower(actorType)))
	if normalized == "" {
		return domain.ActorTypeUser
	}
	return normalized
}

// isValidActorType reports whether actor type values are supported by app/domain rules.
func isValidActorType(actorType domain.ActorType) bool {
	switch actorType {
	case domain.ActorTypeUser, domain.ActorTypeAgent, domain.ActorTypeSystem:
		return true
	default:
		return false
	}
}

// toKindAppliesToList maps string scope values into domain kind applies_to values.
func toKindAppliesToList(scopes []string) []domain.KindAppliesTo {
	out := make([]domain.KindAppliesTo, 0, len(scopes))
	for _, scope := range scopes {
		out = append(out, domain.KindAppliesTo(strings.TrimSpace(scope)))
	}
	return out
}

// toKindIDList maps string kind ids into domain kind ids.
func toKindIDList(kindIDs []string) []domain.KindID {
	out := make([]domain.KindID, 0, len(kindIDs))
	for _, kindID := range kindIDs {
		out = append(out, domain.KindID(strings.TrimSpace(kindID)))
	}
	return out
}

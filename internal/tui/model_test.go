package tui

import (
	"context"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"testing"
	"time"

	"charm.land/bubbles/v2/textinput"
	tea "charm.land/bubbletea/v2"
	"charm.land/lipgloss/v2"
	"github.com/evanschultz/kan/internal/app"
	"github.com/evanschultz/kan/internal/domain"
)

// fakeService represents fake service data used by this package.
type fakeService struct {
	projects         []domain.Project
	columns          map[string][]domain.Column
	tasks            map[string][]domain.Task
	lastCreateTask   app.CreateTaskInput
	createTaskCalls  int
	comments         map[string][]domain.Comment
	err              error
	rollups          map[string]domain.DependencyRollup
	changeEvents     map[string][]domain.ChangeEvent
	changeEventsErr  error
	commentCreateErr error
	commentListErr   error
	commentSeq       int
}

// newFakeService constructs fake service.
func newFakeService(projects []domain.Project, columns []domain.Column, tasks []domain.Task) *fakeService {
	colByProject := map[string][]domain.Column{}
	for _, c := range columns {
		colByProject[c.ProjectID] = append(colByProject[c.ProjectID], c)
	}
	taskByProject := map[string][]domain.Task{}
	for _, t := range tasks {
		taskByProject[t.ProjectID] = append(taskByProject[t.ProjectID], t)
	}
	return &fakeService{
		projects:     projects,
		columns:      colByProject,
		tasks:        taskByProject,
		comments:     map[string][]domain.Comment{},
		rollups:      map[string]domain.DependencyRollup{},
		changeEvents: map[string][]domain.ChangeEvent{},
	}
}

// ListProjects lists projects.
func (f *fakeService) ListProjects(context.Context, bool) ([]domain.Project, error) {
	if f.err != nil {
		return nil, f.err
	}
	out := make([]domain.Project, len(f.projects))
	copy(out, f.projects)
	return out, nil
}

// ListColumns lists columns.
func (f *fakeService) ListColumns(_ context.Context, projectID string, includeArchived bool) ([]domain.Column, error) {
	if f.err != nil {
		return nil, f.err
	}
	cols := f.columns[projectID]
	out := make([]domain.Column, 0, len(cols))
	for _, c := range cols {
		if !includeArchived && c.ArchivedAt != nil {
			continue
		}
		out = append(out, c)
	}
	return out, nil
}

// ListTasks lists tasks.
func (f *fakeService) ListTasks(_ context.Context, projectID string, includeArchived bool) ([]domain.Task, error) {
	if f.err != nil {
		return nil, f.err
	}
	tasks := f.tasks[projectID]
	out := make([]domain.Task, 0, len(tasks))
	for _, task := range tasks {
		if !includeArchived && task.ArchivedAt != nil {
			continue
		}
		out = append(out, task)
	}
	return out, nil
}

// CreateComment creates one ownership-attributed comment.
func (f *fakeService) CreateComment(_ context.Context, in app.CreateCommentInput) (domain.Comment, error) {
	if f.commentCreateErr != nil {
		return domain.Comment{}, f.commentCreateErr
	}
	f.commentSeq++
	comment, err := domain.NewComment(domain.CommentInput{
		ID:           fmt.Sprintf("cm-%d", f.commentSeq),
		ProjectID:    in.ProjectID,
		TargetType:   in.TargetType,
		TargetID:     in.TargetID,
		BodyMarkdown: in.BodyMarkdown,
		ActorType:    in.ActorType,
		AuthorName:   in.AuthorName,
	}, time.Now().UTC())
	if err != nil {
		return domain.Comment{}, err
	}
	key := commentThreadKey(comment.ProjectID, comment.TargetType, comment.TargetID)
	f.comments[key] = append(f.comments[key], comment)
	return comment, nil
}

// ListCommentsByTarget lists comments for one concrete comment target.
func (f *fakeService) ListCommentsByTarget(_ context.Context, in app.ListCommentsByTargetInput) ([]domain.Comment, error) {
	if f.commentListErr != nil {
		return nil, f.commentListErr
	}
	key := commentThreadKey(in.ProjectID, in.TargetType, in.TargetID)
	out := append([]domain.Comment(nil), f.comments[key]...)
	return out, nil
}

// ListProjectChangeEvents lists persisted activity entries.
func (f *fakeService) ListProjectChangeEvents(_ context.Context, projectID string, limit int) ([]domain.ChangeEvent, error) {
	if f.changeEventsErr != nil {
		return nil, f.changeEventsErr
	}
	events := append([]domain.ChangeEvent(nil), f.changeEvents[projectID]...)
	if limit > 0 && len(events) > limit {
		events = events[:limit]
	}
	return events, nil
}

// GetProjectDependencyRollup returns project dependency rollup totals.
func (f *fakeService) GetProjectDependencyRollup(_ context.Context, projectID string) (domain.DependencyRollup, error) {
	if f.err != nil {
		return domain.DependencyRollup{}, f.err
	}
	if rollup, ok := f.rollups[projectID]; ok {
		return rollup, nil
	}
	tasks := f.tasks[projectID]
	rollup := domain.DependencyRollup{
		ProjectID:  projectID,
		TotalItems: len(tasks),
	}
	stateByID := map[string]domain.LifecycleState{}
	for _, task := range tasks {
		stateByID[task.ID] = task.LifecycleState
	}
	for _, task := range tasks {
		dependsOn := uniqueTrimmed(task.Metadata.DependsOn)
		blockedBy := uniqueTrimmed(task.Metadata.BlockedBy)
		if len(dependsOn) > 0 {
			rollup.ItemsWithDependencies++
			rollup.DependencyEdges += len(dependsOn)
		}
		if len(blockedBy) > 0 || strings.TrimSpace(task.Metadata.BlockedReason) != "" {
			rollup.BlockedItems++
		}
		rollup.BlockedByEdges += len(blockedBy)
		for _, depID := range dependsOn {
			state, ok := stateByID[depID]
			if !ok || state != domain.StateDone {
				rollup.UnresolvedDependencyEdges++
			}
		}
	}
	return rollup, nil
}

// SearchTaskMatches handles search task matches.
func (f *fakeService) SearchTaskMatches(ctx context.Context, in app.SearchTasksFilter) ([]app.TaskMatch, error) {
	query := strings.ToLower(strings.TrimSpace(in.Query))
	stateSet := map[string]struct{}{}
	for _, state := range in.States {
		state = strings.ToLower(strings.TrimSpace(state))
		if state == "" {
			continue
		}
		stateSet[state] = struct{}{}
	}
	allowAllStates := len(stateSet) == 0
	out := make([]app.TaskMatch, 0)

	projectIDs := make([]string, 0)
	if in.CrossProject {
		for _, p := range f.projects {
			if !in.IncludeArchived && p.ArchivedAt != nil {
				continue
			}
			projectIDs = append(projectIDs, p.ID)
		}
	} else {
		projectIDs = append(projectIDs, in.ProjectID)
	}

	for _, projectID := range projectIDs {
		project, ok := f.projectByID(projectID)
		if !ok {
			continue
		}
		for _, task := range f.tasks[projectID] {
			stateID := "todo"
			columnName := ""
			for _, c := range f.columns[projectID] {
				if c.ID == task.ColumnID {
					columnName = strings.ToLower(strings.ReplaceAll(c.Name, " ", "-"))
					break
				}
			}
			if columnName != "" {
				switch columnName {
				case "to-do", "todo":
					stateID = "todo"
				case "in-progress", "progress", "doing":
					stateID = "progress"
				default:
					stateID = columnName
				}
			}
			if task.ArchivedAt != nil {
				if !in.IncludeArchived {
					continue
				}
				stateID = "archived"
			}
			if !allowAllStates {
				if _, ok := stateSet[stateID]; !ok {
					continue
				}
			}
			if query != "" {
				matched := strings.Contains(strings.ToLower(task.Title), query) || strings.Contains(strings.ToLower(task.Description), query)
				if !matched {
					for _, label := range task.Labels {
						if strings.Contains(strings.ToLower(label), query) {
							matched = true
							break
						}
					}
				}
				if !matched {
					continue
				}
			}
			out = append(out, app.TaskMatch{
				Project: project,
				Task:    task,
				StateID: stateID,
			})
		}
	}
	return out, nil
}

// CreateProjectWithMetadata creates project with metadata.
func (f *fakeService) CreateProjectWithMetadata(_ context.Context, in app.CreateProjectInput) (domain.Project, error) {
	project, err := domain.NewProject("p-new", in.Name, in.Description, time.Now().UTC())
	if err != nil {
		return domain.Project{}, err
	}
	if err := project.UpdateDetails(project.Name, project.Description, in.Metadata, time.Now().UTC()); err != nil {
		return domain.Project{}, err
	}
	f.projects = append(f.projects, project)
	if _, ok := f.columns[project.ID]; !ok {
		now := time.Now().UTC()
		c1, _ := domain.NewColumn("c-new-1", project.ID, "To Do", 0, 0, now)
		c2, _ := domain.NewColumn("c-new-2", project.ID, "In Progress", 1, 0, now)
		c3, _ := domain.NewColumn("c-new-3", project.ID, "Done", 2, 0, now)
		f.columns[project.ID] = []domain.Column{c1, c2, c3}
	}
	if _, ok := f.tasks[project.ID]; !ok {
		f.tasks[project.ID] = []domain.Task{}
	}
	return project, nil
}

// UpdateProject updates state for the requested operation.
func (f *fakeService) UpdateProject(_ context.Context, in app.UpdateProjectInput) (domain.Project, error) {
	for idx := range f.projects {
		if f.projects[idx].ID != in.ProjectID {
			continue
		}
		if err := f.projects[idx].UpdateDetails(in.Name, in.Description, in.Metadata, time.Now().UTC()); err != nil {
			return domain.Project{}, err
		}
		return f.projects[idx], nil
	}
	return domain.Project{}, app.ErrNotFound
}

// ArchiveProject archives one project.
func (f *fakeService) ArchiveProject(_ context.Context, projectID string) (domain.Project, error) {
	for idx := range f.projects {
		if f.projects[idx].ID != projectID {
			continue
		}
		f.projects[idx].Archive(time.Now().UTC())
		return f.projects[idx], nil
	}
	return domain.Project{}, app.ErrNotFound
}

// RestoreProject restores one project.
func (f *fakeService) RestoreProject(_ context.Context, projectID string) (domain.Project, error) {
	for idx := range f.projects {
		if f.projects[idx].ID != projectID {
			continue
		}
		f.projects[idx].Restore(time.Now().UTC())
		return f.projects[idx], nil
	}
	return domain.Project{}, app.ErrNotFound
}

// DeleteProject hard-deletes one project and associated in-memory fixtures.
func (f *fakeService) DeleteProject(_ context.Context, projectID string) error {
	next := make([]domain.Project, 0, len(f.projects))
	found := false
	for _, project := range f.projects {
		if project.ID == projectID {
			found = true
			continue
		}
		next = append(next, project)
	}
	if !found {
		return app.ErrNotFound
	}
	f.projects = next
	delete(f.columns, projectID)
	delete(f.tasks, projectID)
	return nil
}

// CreateTask creates task.
func (f *fakeService) CreateTask(_ context.Context, in app.CreateTaskInput) (domain.Task, error) {
	f.lastCreateTask = in
	f.createTaskCalls++
	pos := 0
	for _, t := range f.tasks[in.ProjectID] {
		if t.ColumnID == in.ColumnID && t.Position >= pos {
			pos = t.Position + 1
		}
	}
	task, err := domain.NewTask(domain.TaskInput{
		ID:          "t-new",
		ProjectID:   in.ProjectID,
		ParentID:    in.ParentID,
		Kind:        in.Kind,
		Scope:       in.Scope,
		ColumnID:    in.ColumnID,
		Position:    pos,
		Title:       in.Title,
		Description: in.Description,
		Priority:    in.Priority,
		DueAt:       in.DueAt,
		Labels:      in.Labels,
		Metadata:    in.Metadata,
	}, time.Now().UTC())
	if err != nil {
		return domain.Task{}, err
	}
	f.tasks[in.ProjectID] = append(f.tasks[in.ProjectID], task)
	return task, nil
}

// UpdateTask updates state for the requested operation.
func (f *fakeService) UpdateTask(_ context.Context, in app.UpdateTaskInput) (domain.Task, error) {
	for projectID := range f.tasks {
		for idx := range f.tasks[projectID] {
			if f.tasks[projectID][idx].ID != in.TaskID {
				continue
			}
			f.tasks[projectID][idx].Title = strings.TrimSpace(in.Title)
			f.tasks[projectID][idx].Description = strings.TrimSpace(in.Description)
			f.tasks[projectID][idx].Priority = in.Priority
			f.tasks[projectID][idx].DueAt = in.DueAt
			f.tasks[projectID][idx].Labels = in.Labels
			if in.Metadata != nil {
				f.tasks[projectID][idx].Metadata = *in.Metadata
			}
			return f.tasks[projectID][idx], nil
		}
	}
	return domain.Task{}, app.ErrNotFound
}

// MoveTask moves task.
func (f *fakeService) MoveTask(_ context.Context, taskID, toColumnID string, position int) (domain.Task, error) {
	for projectID := range f.tasks {
		for idx := range f.tasks[projectID] {
			if f.tasks[projectID][idx].ID == taskID {
				f.tasks[projectID][idx].ColumnID = toColumnID
				f.tasks[projectID][idx].Position = position
				for _, column := range f.columns[projectID] {
					if column.ID != toColumnID {
						continue
					}
					switch strings.ToLower(strings.TrimSpace(strings.ReplaceAll(column.Name, " ", "-"))) {
					case "to-do", "todo":
						f.tasks[projectID][idx].LifecycleState = domain.StateTodo
					case "in-progress", "progress", "doing":
						f.tasks[projectID][idx].LifecycleState = domain.StateProgress
					case "done", "complete", "completed":
						f.tasks[projectID][idx].LifecycleState = domain.StateDone
					case "archived", "archive":
						f.tasks[projectID][idx].LifecycleState = domain.StateArchived
					default:
						// Keep the prior state when the column name doesn't map to canonical lifecycle values.
					}
					break
				}
				return f.tasks[projectID][idx], nil
			}
		}
	}
	return domain.Task{}, app.ErrNotFound
}

// DeleteTask deletes task.
func (f *fakeService) DeleteTask(_ context.Context, taskID string, mode app.DeleteMode) error {
	for projectID := range f.tasks {
		for idx := range f.tasks[projectID] {
			task := f.tasks[projectID][idx]
			if task.ID != taskID {
				continue
			}
			switch mode {
			case app.DeleteModeArchive:
				now := time.Now().UTC()
				f.tasks[projectID][idx].ArchivedAt = &now
				return nil
			case app.DeleteModeHard:
				f.tasks[projectID] = append(f.tasks[projectID][:idx], f.tasks[projectID][idx+1:]...)
				return nil
			default:
				return app.ErrInvalidDeleteMode
			}
		}
	}
	return app.ErrNotFound
}

// RestoreTask restores task.
func (f *fakeService) RestoreTask(_ context.Context, taskID string) (domain.Task, error) {
	for projectID := range f.tasks {
		for idx := range f.tasks[projectID] {
			if f.tasks[projectID][idx].ID == taskID {
				f.tasks[projectID][idx].ArchivedAt = nil
				return f.tasks[projectID][idx], nil
			}
		}
	}
	return domain.Task{}, app.ErrNotFound
}

// RenameTask renames task.
func (f *fakeService) RenameTask(_ context.Context, taskID, title string) (domain.Task, error) {
	for projectID := range f.tasks {
		for idx := range f.tasks[projectID] {
			if f.tasks[projectID][idx].ID == taskID {
				f.tasks[projectID][idx].Title = strings.TrimSpace(title)
				return f.tasks[projectID][idx], nil
			}
		}
	}
	return domain.Task{}, app.ErrNotFound
}

// projectByID returns project by id.
func (f *fakeService) projectByID(projectID string) (domain.Project, bool) {
	for _, project := range f.projects {
		if project.ID == projectID {
			return project, true
		}
	}
	return domain.Project{}, false
}

// taskByID returns task by id.
func (f *fakeService) taskByID(taskID string) (domain.Task, bool) {
	for projectID := range f.tasks {
		for _, task := range f.tasks[projectID] {
			if task.ID == taskID {
				return task, true
			}
		}
	}
	return domain.Task{}, false
}

// commentThreadKey builds a deterministic key for one comment target.
func commentThreadKey(projectID string, targetType domain.CommentTargetType, targetID string) string {
	return strings.TrimSpace(projectID) + "|" + strings.TrimSpace(string(targetType)) + "|" + strings.TrimSpace(targetID)
}

// TestModelLoadAndNavigation verifies behavior for the covered scenario.
func TestModelLoadAndNavigation(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c1, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	c2, _ := domain.NewColumn("c2", p.ID, "Done", 1, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c1.ID,
		Position:  0,
		Title:     "Ship",
		Priority:  domain.PriorityMedium,
	}, now)

	svc := newFakeService([]domain.Project{p}, []domain.Column{c1, c2}, []domain.Task{task})
	m := loadReadyModel(t, NewModel(svc))

	if len(m.projects) != 1 || len(m.columns) != 2 || len(m.tasks) != 1 {
		t.Fatalf("unexpected loaded model: %#v", m)
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyRight})
	if m.selectedColumn != 1 {
		t.Fatalf("expected selectedColumn=1, got %d", m.selectedColumn)
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyLeft})
	if m.selectedColumn != 0 {
		t.Fatalf("expected selectedColumn=0, got %d", m.selectedColumn)
	}
}

// TestModelQuickAddMoveArchiveRestoreDelete verifies behavior for the covered scenario.
func TestModelQuickAddMoveArchiveRestoreDelete(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c1, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	c2, _ := domain.NewColumn("c2", p.ID, "Done", 1, 0, now)
	existing, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c1.ID,
		Position:  0,
		Title:     "Existing",
		Priority:  domain.PriorityLow,
	}, now)

	svc := newFakeService([]domain.Project{p}, []domain.Column{c1, c2}, []domain.Task{existing})
	m := loadReadyModel(t, NewModel(svc))

	m = applyMsg(t, m, keyRune('n'))
	m = applyMsg(t, m, keyRune('N'))
	m = applyMsg(t, m, keyRune('e'))
	m = applyMsg(t, m, keyRune('w'))
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if len(svc.tasks[p.ID]) != 2 {
		t.Fatalf("expected 2 tasks after quick add, got %d", len(svc.tasks[p.ID]))
	}

	m = applyMsg(t, m, keyRune(']'))
	moved, ok := svc.taskByID("t-new")
	if !ok || moved.ColumnID != c2.ID {
		t.Fatalf("expected created task to move to column %q, got %#v ok=%t", c2.ID, moved, ok)
	}

	m = applyMsg(t, m, keyRune('d'))
	if m.mode != modeConfirmAction {
		t.Fatalf("expected confirm mode for archive, got %v", m.mode)
	}
	m.confirmChoice = 0
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	archived, ok := svc.taskByID("t-new")
	if !ok || archived.ArchivedAt == nil {
		t.Fatalf("expected selected task archived, got %#v ok=%t", archived, ok)
	}
	m = applyMsg(t, m, keyRune('u'))
	restored, ok := svc.taskByID("t-new")
	if !ok || restored.ArchivedAt != nil {
		t.Fatalf("expected selected task restored, got %#v ok=%t", restored, ok)
	}

	m = applyMsg(t, m, keyRune('D'))
	if m.mode != modeConfirmAction {
		t.Fatalf("expected confirm mode for hard delete, got %v", m.mode)
	}
	m = applyMsg(t, m, keyRune('y'))
	if len(svc.tasks[p.ID]) != 1 {
		t.Fatalf("expected hard delete to remove task, got %d tasks", len(svc.tasks[p.ID]))
	}
}

// TestModelCreateTaskFocusesNewTask verifies that create-task reload focuses the created row.
func TestModelCreateTaskFocusesNewTask(t *testing.T) {
	now := time.Date(2026, 2, 22, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	existing, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Existing task",
		Priority:  domain.PriorityMedium,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{existing})
	m := loadReadyModel(t, NewModel(svc))

	m = applyMsg(t, m, keyRune('n'))
	for _, r := range []rune("New focus task") {
		m = applyMsg(t, m, keyRune(r))
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})

	if task, ok := m.selectedTaskInCurrentColumn(); !ok || task.ID != "t-new" {
		t.Fatalf("expected focus on created task t-new, got %#v ok=%t", task, ok)
	}
	if m.selectedTask != 1 {
		t.Fatalf("expected selectedTask index to move to new row, got %d", m.selectedTask)
	}
}

// TestModelProjectSwitchAndSearch verifies behavior for the covered scenario.
func TestModelProjectSwitchAndSearch(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p1, _ := domain.NewProject("p1", "A", "", now)
	p2, _ := domain.NewProject("p2", "B", "", now)
	c1, _ := domain.NewColumn("c1", p1.ID, "To Do", 0, 0, now)
	c2, _ := domain.NewColumn("c2", p2.ID, "To Do", 0, 0, now)
	t1, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p1.ID,
		ColumnID:  c1.ID,
		Position:  0,
		Title:     "Alpha task",
		Priority:  domain.PriorityLow,
	}, now)
	t2, _ := domain.NewTask(domain.TaskInput{
		ID:        "t2",
		ProjectID: p2.ID,
		ColumnID:  c2.ID,
		Position:  0,
		Title:     "Beta task",
		Priority:  domain.PriorityLow,
	}, now)

	svc := newFakeService([]domain.Project{p1, p2}, []domain.Column{c1, c2}, []domain.Task{t1, t2})
	m := loadReadyModel(t, NewModel(svc))

	m = applyMsg(t, m, keyRune('p'))
	if m.mode != modeProjectPicker {
		t.Fatalf("expected project picker mode, got %v", m.mode)
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyDown})
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if m.selectedProject != 1 {
		t.Fatalf("expected selectedProject=1 after picker choose, got %d", m.selectedProject)
	}

	m = applyMsg(t, m, keyRune('/'))
	m = applyMsg(t, m, keyRune('B'))
	m = applyMsg(t, m, keyRune('e'))
	m = applyMsg(t, m, keyRune('t'))
	m = applyMsg(t, m, keyRune('a'))
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if len(m.tasks) != 1 || !strings.Contains(m.tasks[0].Title, "Beta") {
		t.Fatalf("expected filtered tasks to include only beta, got %#v", m.tasks)
	}
}

// TestModelCrossProjectSearchResultsAndJump verifies behavior for the covered scenario.
func TestModelCrossProjectSearchResultsAndJump(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p1, _ := domain.NewProject("p1", "Inbox", "", now)
	p2, _ := domain.NewProject("p2", "Client", "", now)
	c1, _ := domain.NewColumn("c1", p1.ID, "To Do", 0, 0, now)
	c2, _ := domain.NewColumn("c2", p2.ID, "To Do", 0, 0, now)
	t1, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p1.ID,
		ColumnID:  c1.ID,
		Position:  0,
		Title:     "Local task",
		Priority:  domain.PriorityLow,
	}, now)
	t2, _ := domain.NewTask(domain.TaskInput{
		ID:        "t2",
		ProjectID: p2.ID,
		ColumnID:  c2.ID,
		Position:  0,
		Title:     "Client roadmap",
		Priority:  domain.PriorityLow,
	}, now)

	svc := newFakeService([]domain.Project{p1, p2}, []domain.Column{c1, c2}, []domain.Task{t1, t2})
	m := loadReadyModel(t, NewModel(svc))
	m = applyMsg(t, m, keyRune('/'))
	m.searchCrossProject = true
	m = applyMsg(t, m, keyRune('c'))
	m = applyMsg(t, m, keyRune('l'))
	m = applyMsg(t, m, keyRune('i'))
	m = applyMsg(t, m, keyRune('e'))
	m = applyMsg(t, m, keyRune('n'))
	m = applyMsg(t, m, keyRune('t'))
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if m.mode != modeSearchResults {
		t.Fatalf("expected search results mode, got %v", m.mode)
	}
	if len(m.searchMatches) == 0 || m.searchMatches[0].Task.ID != "t2" {
		t.Fatalf("expected cross-project match for t2, got %#v", m.searchMatches)
	}

	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if m.selectedProject != 1 {
		t.Fatalf("expected jump to second project, got %d", m.selectedProject)
	}
	if task, ok := m.selectedTaskInCurrentColumn(); !ok || task.ID != "t2" {
		t.Fatalf("expected selected task t2 after jump, got %#v ok=%t", task, ok)
	}
}

// TestModelAddAndEditProject verifies behavior for the covered scenario.
func TestModelAddAndEditProject(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	existing, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-existing",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Existing task",
		Priority:  domain.PriorityMedium,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{existing})
	m := loadReadyModel(t, NewModel(svc))

	m = applyMsg(t, m, keyRune('N'))
	if m.mode != modeAddProject {
		t.Fatalf("expected add project mode, got %v", m.mode)
	}
	m = applyMsg(t, m, keyRune('R'))
	m = applyMsg(t, m, keyRune('o'))
	m = applyMsg(t, m, keyRune('a'))
	m = applyMsg(t, m, keyRune('d'))
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if len(m.projects) < 2 {
		t.Fatalf("expected project created, got %#v", m.projects)
	}
	if m.selectedProject != len(m.projects)-1 {
		t.Fatalf("expected selection on new project, got %d", m.selectedProject)
	}
	selected := m.projects[m.selectedProject]
	if selected.ID != "p-new" {
		t.Fatalf("expected created project selected, got %q", selected.ID)
	}
	if len(m.tasks) != 0 {
		t.Fatalf("expected fresh project task list, got %#v", m.tasks)
	}
	for _, column := range m.columns {
		if column.ProjectID != selected.ID {
			t.Fatalf("expected columns for project %q, got %#v", selected.ID, m.columns)
		}
	}

	m = applyMsg(t, m, keyRune('M'))
	if m.mode != modeEditProject {
		t.Fatalf("expected edit project mode, got %v", m.mode)
	}
	m.projectFormInputs[0].SetValue("Renamed")
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if got := m.projects[m.selectedProject].Name; got != "Renamed" {
		t.Fatalf("expected project renamed, got %q", got)
	}
}

// TestModelCommandPaletteAndQuickActions verifies behavior for the covered scenario.
func TestModelCommandPaletteAndQuickActions(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Task",
		Priority:  domain.PriorityLow,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task})
	m := loadReadyModel(t, NewModel(svc))

	m = applyMsg(t, m, keyRune(':'))
	if m.mode != modeCommandPalette {
		t.Fatalf("expected command palette mode, got %v", m.mode)
	}
	m = applyMsg(t, m, keyRune('s'))
	m = applyMsg(t, m, keyRune('e'))
	m = applyMsg(t, m, keyRune('a'))
	m = applyMsg(t, m, keyRune('r'))
	m = applyMsg(t, m, keyRune('c'))
	m = applyMsg(t, m, keyRune('h'))
	m = applyMsg(t, m, keyRune('-'))
	m = applyMsg(t, m, keyRune('a'))
	m = applyMsg(t, m, keyRune('l'))
	m = applyMsg(t, m, keyRune('l'))
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if m.mode != modeSearch {
		t.Fatalf("expected search mode after search-all, got %v", m.mode)
	}
	if !m.searchCrossProject {
		t.Fatal("expected search-all command to enable cross-project scope")
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEscape})

	updated, cmd := m.executeCommandPalette("search-project")
	m = applyResult(t, updated, cmd)
	if m.mode != modeSearch {
		t.Fatalf("expected search mode after search-project, got %v", m.mode)
	}
	if m.searchCrossProject {
		t.Fatal("expected search-project command to disable cross-project scope")
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEscape})

	m = applyMsg(t, m, keyRune('.'))
	if m.mode != modeQuickActions {
		t.Fatalf("expected quick actions mode, got %v", m.mode)
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if m.mode != modeTaskInfo {
		t.Fatalf("expected quick action enter to open task info, got %v", m.mode)
	}

	m.mode = modeNone
	m = applyMsg(t, m, keyRune(':'))
	m = applyMsg(t, m, keyRune('z'))
	m = applyMsg(t, m, keyRune('z'))
	m = applyMsg(t, m, keyRune('z'))
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if !strings.Contains(m.status, "unknown command") {
		t.Fatalf("expected unknown command status, got %q", m.status)
	}
}

// TestModelThreadModeProjectAndPostCommentUsesConfiguredIdentity verifies project-thread rendering and comment ownership attribution.
func TestModelThreadModeProjectAndPostCommentUsesConfiguredIdentity(t *testing.T) {
	now := time.Date(2026, 2, 23, 10, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "# Project Overview\n\n- keep momentum", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Task",
		Priority:  domain.PriorityMedium,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task})

	existing, err := domain.NewComment(domain.CommentInput{
		ID:           "cm-existing",
		ProjectID:    p.ID,
		TargetType:   domain.CommentTargetTypeProject,
		TargetID:     p.ID,
		BodyMarkdown: "Initial **project** thread comment",
		ActorType:    domain.ActorTypeSystem,
		AuthorName:   "system-bot",
	}, now)
	if err != nil {
		t.Fatalf("NewComment(existing) error = %v", err)
	}
	projectKey := commentThreadKey(p.ID, domain.CommentTargetTypeProject, p.ID)
	svc.comments[projectKey] = append(svc.comments[projectKey], existing)

	m := loadReadyModel(t, NewModel(
		svc,
		WithIdentityConfig(IdentityConfig{
			DisplayName:      "Lane User",
			DefaultActorType: "agent",
		}),
	))

	updated, cmd := m.executeCommandPalette("thread-project")
	m = applyResult(t, updated, cmd)
	if m.mode != modeThread {
		t.Fatalf("expected thread mode, got %v", m.mode)
	}
	if m.threadTarget.TargetType != domain.CommentTargetTypeProject || m.threadTarget.TargetID != p.ID {
		t.Fatalf("unexpected project thread target %#v", m.threadTarget)
	}

	m.threadInput.SetValue("New _markdown_ project comment")
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})

	comments := svc.comments[projectKey]
	if len(comments) != 2 {
		t.Fatalf("expected 2 project comments after post, got %#v", comments)
	}
	last := comments[len(comments)-1]
	if last.AuthorName != "Lane User" {
		t.Fatalf("expected configured author name Lane User, got %q", last.AuthorName)
	}
	if last.ActorType != domain.ActorTypeAgent {
		t.Fatalf("expected configured actor type agent, got %q", last.ActorType)
	}
	if len(m.threadComments) != 2 {
		t.Fatalf("expected in-memory thread comments to append, got %#v", m.threadComments)
	}
	rendered := stripANSI(fmt.Sprint(m.View().Content))
	if !strings.Contains(rendered, "Project Overview") {
		t.Fatalf("expected markdown-rendered project description, got\n%s", rendered)
	}
	if !strings.Contains(rendered, "[agent] Lane User") {
		t.Fatalf("expected ownership metadata in thread view, got\n%s", rendered)
	}
}

// TestModelThreadModeFromTaskInfoAndBack verifies task-info thread shortcut and back navigation.
func TestModelThreadModeFromTaskInfoAndBack(t *testing.T) {
	now := time.Date(2026, 2, 23, 10, 30, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	phase, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-phase",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Kind:      domain.WorkKindPhase,
		Title:     "Phase 1",
		Priority:  domain.PriorityMedium,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{phase})
	m := loadReadyModel(t, NewModel(svc))

	m = applyMsg(t, m, keyRune('i'))
	if m.mode != modeTaskInfo {
		t.Fatalf("expected task info mode, got %v", m.mode)
	}
	m = applyMsg(t, m, keyRune('c'))
	if m.mode != modeThread {
		t.Fatalf("expected task-info shortcut to open thread mode, got %v", m.mode)
	}
	if m.threadTarget.TargetType != domain.CommentTargetTypePhase {
		t.Fatalf("expected phase target type mapping, got %#v", m.threadTarget)
	}

	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEscape})
	if m.mode != modeTaskInfo {
		t.Fatalf("expected esc to return to task info from thread mode, got %v", m.mode)
	}
}

// TestModelThreadCommentIdentityFallbacks verifies safe identity fallback behavior during comment creation.
func TestModelThreadCommentIdentityFallbacks(t *testing.T) {
	now := time.Date(2026, 2, 23, 11, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Task",
		Priority:  domain.PriorityLow,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task})
	m := loadReadyModel(t, NewModel(
		svc,
		WithIdentityConfig(IdentityConfig{
			DisplayName:      " ",
			DefaultActorType: "robot",
		}),
	))

	updated, cmd := m.executeCommandPalette("thread-item")
	m = applyResult(t, updated, cmd)
	if m.mode != modeThread {
		t.Fatalf("expected work-item thread mode, got %v", m.mode)
	}
	m.threadInput.SetValue("fallback check")
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})

	itemKey := commentThreadKey(p.ID, domain.CommentTargetTypeTask, task.ID)
	comments := svc.comments[itemKey]
	if len(comments) != 1 {
		t.Fatalf("expected one posted comment, got %#v", comments)
	}
	if comments[0].AuthorName != "kan-user" {
		t.Fatalf("expected fallback author name kan-user, got %q", comments[0].AuthorName)
	}
	if comments[0].ActorType != domain.ActorTypeUser {
		t.Fatalf("expected fallback actor type user, got %q", comments[0].ActorType)
	}
}

// TestCommentTargetTypeForWorkKind verifies work-kind to comment-target mapping coverage.
func TestCommentTargetTypeForWorkKind(t *testing.T) {
	cases := []struct {
		kind   domain.WorkKind
		want   domain.CommentTargetType
		wantOK bool
	}{
		{kind: domain.WorkKindTask, want: domain.CommentTargetTypeTask, wantOK: true},
		{kind: domain.WorkKindSubtask, want: domain.CommentTargetTypeSubtask, wantOK: true},
		{kind: domain.WorkKindPhase, want: domain.CommentTargetTypePhase, wantOK: true},
		{kind: domain.WorkKindDecision, want: domain.CommentTargetTypeDecision, wantOK: true},
		{kind: domain.WorkKindNote, want: domain.CommentTargetTypeNote, wantOK: true},
		{kind: domain.WorkKind("unknown"), want: "", wantOK: false},
	}

	for _, tc := range cases {
		got, ok := commentTargetTypeForWorkKind(tc.kind)
		if ok != tc.wantOK {
			t.Fatalf("commentTargetTypeForWorkKind(%q) ok=%t want=%t", tc.kind, ok, tc.wantOK)
		}
		if got != tc.want {
			t.Fatalf("commentTargetTypeForWorkKind(%q) target=%q want=%q", tc.kind, got, tc.want)
		}
	}
}

// TestModelCommandPaletteFuzzyAbbreviationExecutesNewSubtask verifies fuzzy abbreviations can target commands like new-subtask.
func TestModelCommandPaletteFuzzyAbbreviationExecutesNewSubtask(t *testing.T) {
	now := time.Date(2026, 2, 23, 9, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	parent, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-parent",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Parent",
		Priority:  domain.PriorityMedium,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{parent})
	m := loadReadyModel(t, NewModel(svc))

	m = applyMsg(t, m, keyRune(':'))
	m = applyMsg(t, m, keyRune('n'))
	m = applyMsg(t, m, keyRune('s'))
	if len(m.commandMatches) == 0 {
		t.Fatal("expected fuzzy command matches for abbreviation 'ns'")
	}
	if got := m.commandMatches[0].Command; got != "new-subtask" {
		t.Fatalf("expected top fuzzy command match new-subtask, got %q", got)
	}

	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if m.mode != modeAddTask {
		t.Fatalf("expected add-task mode after executing new-subtask, got %v", m.mode)
	}
	if got := m.taskFormKind; got != domain.WorkKindSubtask {
		t.Fatalf("expected task form kind subtask, got %q", got)
	}
	if got := m.taskFormParentID; got != parent.ID {
		t.Fatalf("expected subtask parent %q, got %q", parent.ID, got)
	}
}

// TestModelCommandPaletteHighlightColorApplies verifies highlight-color command updates focused-row styling.
func TestModelCommandPaletteHighlightColorApplies(t *testing.T) {
	now := time.Date(2026, 2, 23, 11, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Styled task",
		Priority:  domain.PriorityMedium,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task})
	m := loadReadyModel(t, NewModel(svc))

	updated, cmd := m.executeCommandPalette("highlight-color")
	m = applyResult(t, updated, cmd)
	if m.mode != modeHighlightColor {
		t.Fatalf("expected highlight-color modal mode, got %v", m.mode)
	}
	m.highlightColorInput.SetValue("201")
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})

	if got := m.highlightColor; got != "201" {
		t.Fatalf("expected stored highlight color 201, got %q", got)
	}
	rendered := fmt.Sprint(m.View().Content)
	if !strings.Contains(rendered, "38;5;201") {
		t.Fatalf("expected focused row rendered with ansi color 201, got\n%s", rendered)
	}
}

// TestModelLabelsConfigCommandSave verifies labels-config command flow updates runtime labels and calls persistence callback.
func TestModelLabelsConfigCommandSave(t *testing.T) {
	now := time.Date(2026, 2, 23, 9, 30, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, nil)

	saveCalls := 0
	var savedSlug string
	var savedGlobal []string
	var savedProject []string
	m := loadReadyModel(t, NewModel(
		svc,
		WithLabelConfig(LabelConfig{
			Global:   []string{"bug"},
			Projects: map[string][]string{"inbox": {"kan"}},
		}),
		WithSaveLabelsConfigCallback(func(projectSlug string, globalLabels, projectLabels []string) error {
			saveCalls++
			savedSlug = projectSlug
			savedGlobal = append([]string(nil), globalLabels...)
			savedProject = append([]string(nil), projectLabels...)
			return nil
		}),
	))

	updated, cmd := m.executeCommandPalette("labels-config")
	m = applyResult(t, updated, cmd)
	if m.mode != modeLabelsConfig {
		t.Fatalf("expected labels config mode, got %v", m.mode)
	}
	if got := m.labelsConfigSlug; got != "inbox" {
		t.Fatalf("expected labels config slug inbox, got %q", got)
	}

	m.labelsConfigInputs[0].SetValue("Bug, chore, bug")
	m.labelsConfigInputs[1].SetValue("Roadmap, kan, roadmap")
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})

	if saveCalls != 1 {
		t.Fatalf("expected one labels save call, got %d", saveCalls)
	}
	if savedSlug != "inbox" {
		t.Fatalf("expected labels save slug inbox, got %q", savedSlug)
	}
	wantGlobal := []string{"bug", "chore"}
	if len(savedGlobal) != len(wantGlobal) {
		t.Fatalf("unexpected saved global labels %#v", savedGlobal)
	}
	for i := range wantGlobal {
		if savedGlobal[i] != wantGlobal[i] {
			t.Fatalf("unexpected saved global label at %d: got %q want %q", i, savedGlobal[i], wantGlobal[i])
		}
	}
	wantProject := []string{"roadmap", "kan"}
	if len(savedProject) != len(wantProject) {
		t.Fatalf("unexpected saved project labels %#v", savedProject)
	}
	for i := range wantProject {
		if savedProject[i] != wantProject[i] {
			t.Fatalf("unexpected saved project label at %d: got %q want %q", i, savedProject[i], wantProject[i])
		}
	}
	if m.mode != modeNone {
		t.Fatalf("expected modal closed after save, got %v", m.mode)
	}
	if !strings.Contains(m.status, "labels config saved") {
		t.Fatalf("expected labels save status, got %q", m.status)
	}
	if len(m.allowedLabelGlobal) != len(wantGlobal) {
		t.Fatalf("unexpected in-memory global labels %#v", m.allowedLabelGlobal)
	}
	for i := range wantGlobal {
		if m.allowedLabelGlobal[i] != wantGlobal[i] {
			t.Fatalf("unexpected in-memory global label at %d: got %q want %q", i, m.allowedLabelGlobal[i], wantGlobal[i])
		}
	}
	projectLabels := m.allowedLabelProject["inbox"]
	if len(projectLabels) != len(wantProject) {
		t.Fatalf("unexpected in-memory project labels %#v", m.allowedLabelProject)
	}
	for i := range wantProject {
		if projectLabels[i] != wantProject[i] {
			t.Fatalf("unexpected in-memory project label at %d: got %q want %q", i, projectLabels[i], wantProject[i])
		}
	}
}

// TestModelLabelsConfigCommandSaveScopedBranchPhase verifies branch/phase labels persist through scoped labels-config saves.
func TestModelLabelsConfigCommandSaveScopedBranchPhase(t *testing.T) {
	now := time.Date(2026, 2, 23, 9, 30, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	branch, _ := domain.NewTask(domain.TaskInput{
		ID:        "b1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		ParentID:  "",
		Kind:      domain.WorkKind("branch"),
		Scope:     domain.KindAppliesToBranch,
		Title:     "Branch",
		Priority:  domain.PriorityMedium,
		Labels:    []string{"branch-old"},
	}, now)
	phase, _ := domain.NewTask(domain.TaskInput{
		ID:        "ph1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  1,
		ParentID:  branch.ID,
		Kind:      domain.WorkKindPhase,
		Scope:     domain.KindAppliesToPhase,
		Title:     "Phase",
		Priority:  domain.PriorityMedium,
		Labels:    []string{"phase-old"},
	}, now)
	leaf, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  2,
		ParentID:  phase.ID,
		Kind:      domain.WorkKindTask,
		Scope:     domain.KindAppliesToTask,
		Title:     "Leaf",
		Priority:  domain.PriorityMedium,
	}, now)

	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{branch, phase, leaf})
	m := loadReadyModel(t, NewModel(
		svc,
		WithLabelConfig(LabelConfig{
			Global:   []string{"bug"},
			Projects: map[string][]string{"inbox": {"roadmap"}},
		}),
		WithSaveLabelsConfigCallback(func(_ string, _ []string, _ []string) error { return nil }),
	))
	m.projectionRootTaskID = branch.ID
	m.selectedColumn = 0
	m.selectedTask = 0

	updated, cmd := m.executeCommandPalette("labels-config")
	m = applyResult(t, updated, cmd)
	if m.mode != modeLabelsConfig {
		t.Fatalf("expected labels config mode, got %v", m.mode)
	}
	if len(m.labelsConfigInputs) != 4 {
		t.Fatalf("expected 4 labels config inputs, got %d", len(m.labelsConfigInputs))
	}
	if m.labelsConfigBranchTaskID != branch.ID || m.labelsConfigPhaseTaskID != phase.ID {
		t.Fatalf("expected branch/phase context IDs, got branch=%q phase=%q", m.labelsConfigBranchTaskID, m.labelsConfigPhaseTaskID)
	}
	if got := strings.TrimSpace(m.labelsConfigInputs[2].Value()); got != "branch-old" {
		t.Fatalf("expected branch labels prefill, got %q", got)
	}
	if got := strings.TrimSpace(m.labelsConfigInputs[3].Value()); got != "phase-old" {
		t.Fatalf("expected phase labels prefill, got %q", got)
	}

	m.labelsConfigInputs[2].SetValue("branch-new")
	m.labelsConfigInputs[3].SetValue("phase-new,phase-two")
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})

	findTask := func(taskID string) (domain.Task, bool) {
		for _, task := range svc.tasks[p.ID] {
			if task.ID == taskID {
				return task, true
			}
		}
		return domain.Task{}, false
	}
	updatedBranch, ok := findTask(branch.ID)
	if !ok {
		t.Fatalf("expected branch task %q to exist", branch.ID)
	}
	if len(updatedBranch.Labels) != 1 || updatedBranch.Labels[0] != "branch-new" {
		t.Fatalf("expected branch labels updated, got %#v", updatedBranch.Labels)
	}
	updatedPhase, ok := findTask(phase.ID)
	if !ok {
		t.Fatalf("expected phase task %q to exist", phase.ID)
	}
	if len(updatedPhase.Labels) != 2 || updatedPhase.Labels[0] != "phase-new" || updatedPhase.Labels[1] != "phase-two" {
		t.Fatalf("expected phase labels updated, got %#v", updatedPhase.Labels)
	}
}

// TestModelCommandPaletteProjectLifecycleActions verifies archive/restore/delete project command flows.
func TestModelCommandPaletteProjectLifecycleActions(t *testing.T) {
	now := time.Date(2026, 2, 23, 9, 30, 0, 0, time.UTC)
	p1, _ := domain.NewProject("p1", "Inbox", "", now)
	p2, _ := domain.NewProject("p2", "Roadmap", "", now)
	c1, _ := domain.NewColumn("c1", p1.ID, "To Do", 0, 0, now)
	c2, _ := domain.NewColumn("c2", p2.ID, "To Do", 0, 0, now)
	svc := newFakeService([]domain.Project{p1, p2}, []domain.Column{c1, c2}, nil)
	m := loadReadyModel(t, NewModel(
		svc,
		WithConfirmConfig(ConfirmConfig{
			Archive:    false,
			HardDelete: false,
			Restore:    false,
		}),
	))
	m.showArchived = true

	updated, cmd := m.executeCommandPalette("toggle-selection-mode")
	m = applyResult(t, updated, cmd)
	if !m.mouseSelectionMode {
		t.Fatal("expected selection mode enabled")
	}

	updated, cmd = m.executeCommandPalette("archive-project")
	m = applyResult(t, updated, cmd)
	if svc.projects[0].ArchivedAt == nil {
		t.Fatalf("expected archived project state, got %#v", svc.projects[0])
	}

	updated, cmd = m.executeCommandPalette("restore-project")
	m = applyResult(t, updated, cmd)
	if svc.projects[0].ArchivedAt != nil {
		t.Fatalf("expected restored project state, got %#v", svc.projects[0])
	}

	updated, cmd = m.executeCommandPalette("delete-project")
	m = applyResult(t, updated, cmd)
	if len(svc.projects) != 1 {
		t.Fatalf("expected one project after delete, got %d", len(svc.projects))
	}
	if svc.projects[0].ID != p2.ID {
		t.Fatalf("expected remaining project %q, got %#v", p2.ID, svc.projects)
	}
}

// TestModelProjectLifecycleConfirmBranches verifies confirm-mode branches for project lifecycle actions.
func TestModelProjectLifecycleConfirmBranches(t *testing.T) {
	now := time.Date(2026, 2, 23, 9, 30, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, nil)
	m := loadReadyModel(t, NewModel(svc))

	updated, cmd := m.archiveCurrentProject(true)
	m = applyResult(t, updated, cmd)
	if m.mode != modeConfirmAction || m.pendingConfirm.Kind != "archive-project" {
		t.Fatalf("expected archive-project confirm mode, got mode=%v confirm=%#v", m.mode, m.pendingConfirm)
	}
	m.mode = modeNone
	m.pendingConfirm = confirmAction{}

	archived, err := svc.ArchiveProject(context.Background(), p.ID)
	if err != nil {
		t.Fatalf("ArchiveProject() setup error = %v", err)
	}
	svc.projects[0] = archived
	m.projects[0] = archived
	m.showArchived = true

	updated, cmd = m.restoreCurrentProject(true)
	m = applyResult(t, updated, cmd)
	if m.mode != modeConfirmAction || m.pendingConfirm.Kind != "restore-project" {
		t.Fatalf("expected restore-project confirm mode, got mode=%v confirm=%#v", m.mode, m.pendingConfirm)
	}
	m.mode = modeNone

	updated, cmd = m.deleteCurrentProject(true)
	m = applyResult(t, updated, cmd)
	if m.mode != modeConfirmAction || m.pendingConfirm.Kind != "delete-project" {
		t.Fatalf("expected delete-project confirm mode, got mode=%v confirm=%#v", m.mode, m.pendingConfirm)
	}
}

// TestModelProjectLifecycleGuardsAndSelection verifies project lifecycle guard statuses and next-visible selection.
func TestModelProjectLifecycleGuardsAndSelection(t *testing.T) {
	now := time.Date(2026, 2, 23, 9, 30, 0, 0, time.UTC)

	empty := loadReadyModel(t, NewModel(newFakeService(nil, nil, nil)))
	updated, cmd := empty.archiveCurrentProject(true)
	empty = applyResult(t, updated, cmd)
	if empty.status != "no project selected" {
		t.Fatalf("expected no-project archive status, got %q", empty.status)
	}
	updated, cmd = empty.restoreCurrentProject(true)
	empty = applyResult(t, updated, cmd)
	if empty.status != "no project selected" {
		t.Fatalf("expected no-project restore status, got %q", empty.status)
	}
	updated, cmd = empty.deleteCurrentProject(true)
	empty = applyResult(t, updated, cmd)
	if empty.status != "no project selected" {
		t.Fatalf("expected no-project delete status, got %q", empty.status)
	}

	p1, _ := domain.NewProject("p1", "Inbox", "", now)
	p2, _ := domain.NewProject("p2", "Roadmap", "", now)
	p3, _ := domain.NewProject("p3", "Ops", "", now)
	p2.Archive(now.Add(time.Minute))

	c1, _ := domain.NewColumn("c1", p1.ID, "To Do", 0, 0, now)
	c2, _ := domain.NewColumn("c2", p2.ID, "To Do", 0, 0, now)
	c3, _ := domain.NewColumn("c3", p3.ID, "To Do", 0, 0, now)

	svc := newFakeService([]domain.Project{p1, p2, p3}, []domain.Column{c1, c2, c3}, nil)
	m := loadReadyModel(t, NewModel(svc))
	m.projects[1] = p2
	m.showArchived = false

	updated, cmd = m.restoreCurrentProject(true)
	m = applyResult(t, updated, cmd)
	if m.status != "project is not archived" {
		t.Fatalf("expected non-archived restore guard status, got %q", m.status)
	}
	if m.mode == modeConfirmAction {
		t.Fatalf("expected no confirm mode for non-archived restore, got %v", m.mode)
	}

	updated, cmd = m.archiveCurrentProject(false)
	m = applyResult(t, updated, cmd)
	if got := m.projects[m.selectedProject].ID; got != p3.ID {
		t.Fatalf("expected next visible project %q after archive, got %q", p3.ID, got)
	}
	m.selectedProject = 1
	updated, cmd = m.archiveCurrentProject(true)
	m = applyResult(t, updated, cmd)
	if m.status != "project already archived" {
		t.Fatalf("expected already-archived guard status, got %q", m.status)
	}

	updated, cmd = m.deleteCurrentProject(false)
	m = applyResult(t, updated, cmd)
	if got := m.projects[m.selectedProject].ID; got != p3.ID {
		t.Fatalf("expected delete to skip archived candidates and keep visible project %q, got %q", p3.ID, got)
	}

	updated, cmd = m.applyConfirmedAction(confirmAction{Kind: "mystery"})
	m = applyResult(t, updated, cmd)
	if m.status != "unknown confirm action" {
		t.Fatalf("expected unknown confirm action status, got %q", m.status)
	}
}

// TestModelCommandPaletteBranchLifecycleGuards verifies branch lifecycle commands require a selected branch.
func TestModelCommandPaletteBranchLifecycleGuards(t *testing.T) {
	now := time.Date(2026, 2, 23, 9, 30, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Kind:      domain.WorkKindTask,
		Scope:     domain.KindAppliesToTask,
		Title:     "Task",
		Priority:  domain.PriorityMedium,
	}, now)

	m := loadReadyModel(t, NewModel(newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task})))

	updated, cmd := m.executeCommandPalette("edit-branch")
	m = applyResult(t, updated, cmd)
	if m.status != "select a branch to edit" {
		t.Fatalf("expected edit-branch guard status, got %q", m.status)
	}

	updated, cmd = m.executeCommandPalette("archive-branch")
	m = applyResult(t, updated, cmd)
	if m.status != "select a branch to archive" {
		t.Fatalf("expected archive-branch guard status, got %q", m.status)
	}

	updated, cmd = m.executeCommandPalette("delete-branch")
	m = applyResult(t, updated, cmd)
	if m.status != "select a branch to delete" {
		t.Fatalf("expected delete-branch guard status, got %q", m.status)
	}

	updated, cmd = m.executeCommandPalette("restore-branch")
	m = applyResult(t, updated, cmd)
	if m.status != "select an archived branch to restore" {
		t.Fatalf("expected restore-branch guard status, got %q", m.status)
	}
}

// TestModelCommandPaletteBranchLifecycleActions verifies branch command palette flows.
func TestModelCommandPaletteBranchLifecycleActions(t *testing.T) {
	now := time.Date(2026, 2, 23, 9, 30, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	branch, _ := domain.NewTask(domain.TaskInput{
		ID:        "b1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Kind:      domain.WorkKind("branch"),
		Scope:     domain.KindAppliesToBranch,
		Title:     "Branch",
		Priority:  domain.PriorityMedium,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{branch})
	m := loadReadyModel(t, NewModel(
		svc,
		WithConfirmConfig(ConfirmConfig{
			Archive:    false,
			HardDelete: false,
			Restore:    false,
		}),
	))
	m.showArchived = true

	updated, cmd := m.executeCommandPalette("new-branch")
	m = applyResult(t, updated, cmd)
	if m.mode != modeAddTask || m.taskFormKind != domain.WorkKind("branch") || m.taskFormScope != domain.KindAppliesToBranch {
		t.Fatalf("expected new branch task form defaults, got mode=%v kind=%q scope=%q", m.mode, m.taskFormKind, m.taskFormScope)
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEscape})

	updated, cmd = m.executeCommandPalette("edit-branch")
	m = applyResult(t, updated, cmd)
	if m.mode != modeEditTask || strings.TrimSpace(m.editingTaskID) != branch.ID {
		t.Fatalf("expected branch edit form, got mode=%v task=%q", m.mode, m.editingTaskID)
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEscape})

	updated, cmd = m.executeCommandPalette("archive-branch")
	m = applyResult(t, updated, cmd)
	if len(svc.tasks[p.ID]) != 1 || svc.tasks[p.ID][0].ArchivedAt == nil {
		t.Fatalf("expected archived branch task, got %#v", svc.tasks[p.ID])
	}

	updated, cmd = m.executeCommandPalette("restore-branch")
	m = applyResult(t, updated, cmd)
	if len(svc.tasks[p.ID]) != 1 || svc.tasks[p.ID][0].ArchivedAt != nil {
		t.Fatalf("expected restored branch task, got %#v", svc.tasks[p.ID])
	}

	updated, cmd = m.executeCommandPalette("delete-branch")
	m = applyResult(t, updated, cmd)
	if len(svc.tasks[p.ID]) != 0 {
		t.Fatalf("expected branch hard delete, got %#v", svc.tasks[p.ID])
	}
}

// TestClipboardShortcutHelpers verifies key-detection and input-splice helper behavior for clipboard shortcuts.
func TestClipboardShortcutHelpers(t *testing.T) {
	if !isClipboardCopyKey(tea.KeyPressMsg{Code: 'c', Mod: tea.ModCtrl}) {
		t.Fatal("expected ctrl+c to be recognized as copy")
	}
	if !isClipboardPasteKey(tea.KeyPressMsg{Code: 'v', Mod: tea.ModCtrl}) {
		t.Fatal("expected ctrl+v to be recognized as paste")
	}

	merged, next := spliceRunes("abcd", 2, "XYZ")
	if merged != "abXYZcd" || next != 5 {
		t.Fatalf("unexpected splice result merged=%q next=%d", merged, next)
	}

	in := textinput.New()
	in.SetValue("alpha")
	in.SetCursor(2)

	if handled, _ := applyClipboardShortcutToInput(tea.KeyPressMsg{Code: 'x', Text: "x"}, &in); handled {
		t.Fatal("expected non-clipboard key to bypass clipboard helper")
	}
	if handled, status := applyClipboardShortcutToInput(tea.KeyPressMsg{Code: 'c', Mod: tea.ModCtrl}, &in); !handled || status == "" {
		t.Fatalf("expected copy shortcut handled with status, handled=%t status=%q", handled, status)
	}
	if handled, status := applyClipboardShortcutToInput(tea.KeyPressMsg{Code: 'v', Mod: tea.ModCtrl}, &in); !handled || status == "" {
		t.Fatalf("expected paste shortcut handled with status, handled=%t status=%q", handled, status)
	}
}

// TestModelCommandPaletteWindowedRendering verifies command selection stays visible past the first page.
func TestModelCommandPaletteWindowedRendering(t *testing.T) {
	now := time.Date(2026, 2, 22, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, nil)
	m := loadReadyModel(t, NewModel(svc))

	m = applyMsg(t, m, keyRune(':'))
	for i := 0; i < 12; i++ {
		m = applyMsg(t, m, keyRune('j'))
	}
	if m.commandIndex != 12 {
		t.Fatalf("expected commandIndex=12, got %d", m.commandIndex)
	}

	accent := lipgloss.Color("62")
	muted := lipgloss.Color("241")
	dim := lipgloss.Color("239")
	helpStyle := lipgloss.NewStyle().Foreground(muted)
	out := m.renderModeOverlay(accent, muted, dim, helpStyle, 96)
	selected := m.commandMatches[m.commandIndex].Command
	if !strings.Contains(out, " "+selected) {
		t.Fatalf("expected selected command %q to remain visible in windowed list, got %q", selected, out)
	}
}

// TestModelQuickActionsDisabledOrderingAndBlocking verifies disabled quick actions sort last and cannot execute.
func TestModelQuickActionsDisabledOrderingAndBlocking(t *testing.T) {
	now := time.Date(2026, 2, 22, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, nil)
	m := loadReadyModel(t, NewModel(svc))

	m = applyMsg(t, m, keyRune('.'))
	if m.mode != modeQuickActions {
		t.Fatalf("expected quick actions mode, got %v", m.mode)
	}

	accent := lipgloss.Color("62")
	muted := lipgloss.Color("241")
	dim := lipgloss.Color("239")
	helpStyle := lipgloss.NewStyle().Foreground(muted)
	out := m.renderModeOverlay(accent, muted, dim, helpStyle, 96)
	enabledIdx := strings.Index(out, "Activity Log")
	disabledIdx := strings.Index(out, "Task Info (no task selected)")
	if enabledIdx == -1 || disabledIdx == -1 || enabledIdx > disabledIdx {
		t.Fatalf("expected enabled action before disabled entries, got %q", out)
	}

	m = applyMsg(t, m, keyRune('j')) // move from enabled Activity Log to first disabled row
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if m.mode != modeQuickActions {
		t.Fatalf("expected disabled quick action to stay in quick-actions mode, got %v", m.mode)
	}
	if !strings.Contains(m.status, "unavailable") {
		t.Fatalf("expected unavailable status for disabled quick action, got %q", m.status)
	}
}

// TestModelCommandPaletteReloadConfigAppliesRuntimeSettings verifies behavior for the covered scenario.
func TestModelCommandPaletteReloadConfigAppliesRuntimeSettings(t *testing.T) {
	now := time.Date(2026, 2, 22, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Task",
		Priority:  domain.PriorityMedium,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task})

	rootDir := t.TempDir()
	reloadCalls := 0
	m := loadReadyModel(t, NewModel(
		svc,
		WithReloadConfigCallback(func() (RuntimeConfig, error) {
			reloadCalls++
			return RuntimeConfig{
				DefaultDeleteMode: app.DeleteModeHard,
				TaskFields: TaskFieldConfig{
					ShowPriority:    false,
					ShowDueDate:     false,
					ShowLabels:      false,
					ShowDescription: true,
				},
				Search: SearchConfig{
					CrossProject:    true,
					IncludeArchived: true,
					States:          []string{"todo", "archived"},
				},
				Confirm: ConfirmConfig{
					Delete:     false,
					Archive:    false,
					HardDelete: false,
					Restore:    true,
				},
				Board: BoardConfig{
					ShowWIPWarnings: false,
					GroupBy:         "priority",
				},
				UI: UIConfig{
					DueSoonWindows: []time.Duration{2 * time.Hour},
					ShowDueSummary: false,
				},
				Labels: LabelConfig{
					Global:         []string{"bug"},
					Projects:       map[string][]string{"inbox": {"roadmap"}},
					EnforceAllowed: true,
				},
				ProjectRoots: map[string]string{"inbox": rootDir},
				Keys: KeyConfig{
					CommandPalette: ";",
					QuickActions:   ",",
					MultiSelect:    "x",
					ActivityLog:    "v",
					Undo:           "u",
					Redo:           "U",
				},
			}, nil
		}),
	))

	updated, cmd := m.executeCommandPalette("reload-config")
	m = applyResult(t, updated, cmd)

	if reloadCalls != 1 {
		t.Fatalf("expected one reload callback invocation, got %d", reloadCalls)
	}
	if m.defaultDeleteMode != app.DeleteModeHard {
		t.Fatalf("expected hard default delete mode, got %q", m.defaultDeleteMode)
	}
	if m.taskFields.ShowPriority || m.taskFields.ShowDueDate || m.taskFields.ShowLabels || !m.taskFields.ShowDescription {
		t.Fatalf("unexpected task fields after reload %#v", m.taskFields)
	}
	if !m.searchCrossProject || !m.searchDefaultCrossProject || !m.showArchived || !m.searchDefaultIncludeArchive {
		t.Fatalf("unexpected search scope flags after reload %#v", m)
	}
	if got := strings.Join(m.searchStates, ","); got != "todo,archived" {
		t.Fatalf("unexpected search states after reload %#v", m.searchStates)
	}
	if m.boardGroupBy != "priority" || m.showWIPWarnings {
		t.Fatalf("unexpected board config after reload group=%q wip=%t", m.boardGroupBy, m.showWIPWarnings)
	}
	if m.confirmDelete || m.confirmArchive || m.confirmHardDelete || !m.confirmRestore {
		t.Fatalf("unexpected confirm flags after reload delete=%t archive=%t hard=%t restore=%t", m.confirmDelete, m.confirmArchive, m.confirmHardDelete, m.confirmRestore)
	}
	if len(m.dueSoonWindows) != 1 || m.dueSoonWindows[0] != 2*time.Hour || m.showDueSummary {
		t.Fatalf("unexpected ui config after reload due=%#v summary=%t", m.dueSoonWindows, m.showDueSummary)
	}
	if !m.enforceAllowedLabels || len(m.allowedLabelGlobal) != 1 || m.allowedLabelGlobal[0] != "bug" {
		t.Fatalf("unexpected label config after reload %#v", m.allowedLabelGlobal)
	}
	if got := m.allowedLabelProject["inbox"]; len(got) != 1 || got[0] != "roadmap" {
		t.Fatalf("unexpected per-project labels after reload %#v", m.allowedLabelProject)
	}
	if got := m.projectRoots["inbox"]; got != rootDir {
		t.Fatalf("unexpected project roots after reload %#v", m.projectRoots)
	}
	if m.status != "config reloaded" {
		t.Fatalf("expected config reloaded status, got %q", m.status)
	}

	m = applyMsg(t, m, keyRune(';'))
	if m.mode != modeCommandPalette {
		t.Fatalf("expected command palette open with reloaded keybinding, got %v", m.mode)
	}
}

// TestModelCommandPaletteReloadConfigError verifies behavior for the covered scenario.
func TestModelCommandPaletteReloadConfigError(t *testing.T) {
	now := time.Date(2026, 2, 22, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Task",
		Priority:  domain.PriorityMedium,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task})
	m := loadReadyModel(t, NewModel(svc, WithReloadConfigCallback(func() (RuntimeConfig, error) {
		return RuntimeConfig{}, errors.New("disk read failed")
	})))

	updated, cmd := m.executeCommandPalette("reload-config")
	m = applyResult(t, updated, cmd)
	if !strings.Contains(m.status, "reload config failed") {
		t.Fatalf("expected reload-config error status, got %q", m.status)
	}
}

// TestModelPathsRootsModalSaveAndClear verifies behavior for the covered scenario.
func TestModelPathsRootsModalSaveAndClear(t *testing.T) {
	now := time.Date(2026, 2, 22, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Task",
		Priority:  domain.PriorityMedium,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task})

	rootDir := t.TempDir()
	type saveCall struct {
		slug string
		path string
	}
	saveCalls := make([]saveCall, 0, 2)
	m := loadReadyModel(t, NewModel(
		svc,
		WithSaveProjectRootCallback(func(projectSlug, rootPath string) error {
			saveCalls = append(saveCalls, saveCall{slug: projectSlug, path: rootPath})
			return nil
		}),
	))

	updated, cmd := m.executeCommandPalette("paths-roots")
	m = applyResult(t, updated, cmd)
	if m.mode != modePathsRoots {
		t.Fatalf("expected paths/roots modal mode, got %v", m.mode)
	}
	m.pathsRootInput.SetValue(rootDir)
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})

	absRoot, err := filepath.Abs(rootDir)
	if err != nil {
		t.Fatalf("Abs() error = %v", err)
	}
	if len(saveCalls) != 1 || saveCalls[0].slug != "inbox" || saveCalls[0].path != absRoot {
		t.Fatalf("unexpected save callback calls %#v", saveCalls)
	}
	if got := m.projectRoots["inbox"]; got != absRoot {
		t.Fatalf("expected in-memory project root update to %q, got %#v", absRoot, m.projectRoots)
	}
	if m.status != "project root saved" {
		t.Fatalf("expected project root saved status, got %q", m.status)
	}

	updated, cmd = m.executeCommandPalette("paths-roots")
	m = applyResult(t, updated, cmd)
	m.pathsRootInput.SetValue("")
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if len(saveCalls) != 2 || saveCalls[1].slug != "inbox" || saveCalls[1].path != "" {
		t.Fatalf("unexpected clear callback calls %#v", saveCalls)
	}
	if _, ok := m.projectRoots["inbox"]; ok {
		t.Fatalf("expected root mapping cleared, got %#v", m.projectRoots)
	}
	if m.status != "project root cleared" {
		t.Fatalf("expected project root cleared status, got %q", m.status)
	}
}

// TestModelPathsRootsModalValidationAndSaveError verifies behavior for the covered scenario.
func TestModelPathsRootsModalValidationAndSaveError(t *testing.T) {
	now := time.Date(2026, 2, 22, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Task",
		Priority:  domain.PriorityMedium,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task})

	saveCalls := 0
	m := loadReadyModel(t, NewModel(
		svc,
		WithSaveProjectRootCallback(func(projectSlug, rootPath string) error {
			saveCalls++
			return errors.New("write failed")
		}),
	))

	updated, cmd := m.executeCommandPalette("paths-roots")
	m = applyResult(t, updated, cmd)
	m.pathsRootInput.SetValue(filepath.Join(t.TempDir(), "missing"))
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if m.mode != modePathsRoots {
		t.Fatalf("expected modal to remain open after validation failure, got %v", m.mode)
	}
	if saveCalls != 0 {
		t.Fatalf("expected no callback invocation on validation failure, got %d", saveCalls)
	}
	if !strings.Contains(m.status, "root path not found") {
		t.Fatalf("expected not-found validation message, got %q", m.status)
	}

	validRoot := t.TempDir()
	m.pathsRootInput.SetValue(validRoot)
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if m.mode != modeNone {
		t.Fatalf("expected modal close after callback execution, got %v", m.mode)
	}
	if saveCalls != 1 {
		t.Fatalf("expected one callback invocation after valid submit, got %d", saveCalls)
	}
	if !strings.Contains(m.status, "save root failed") {
		t.Fatalf("expected save error message, got %q", m.status)
	}
}

// TestModelResourcePickerRequiresProjectRootForTaskAttach verifies task attachment does not fall back when project root is missing.
func TestModelResourcePickerRequiresProjectRootForTaskAttach(t *testing.T) {
	now := time.Date(2026, 2, 22, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Task",
		Priority:  domain.PriorityMedium,
	}, now)
	root := t.TempDir()

	m := loadReadyModel(t, NewModel(
		newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task}),
		WithSearchRoots([]string{root}),
	))
	if got := m.resourcePickerRootForCurrentProject(); got != "" {
		t.Fatalf("expected empty project root lookup when mapping is missing, got %q", got)
	}
	m = applyMsg(t, m, keyRune('i'))
	m = applyMsg(t, m, keyRune('r'))
	if m.mode != modeTaskInfo {
		t.Fatalf("expected to remain in task info mode when project root is missing, got %v", m.mode)
	}
	if !strings.Contains(m.status, "set project root first") {
		t.Fatalf("expected missing project-root status, got %q", m.status)
	}
}

// TestModelMouseWheelAndClick verifies behavior for the covered scenario.
func TestModelMouseWheelAndClick(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c1, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	c2, _ := domain.NewColumn("c2", p.ID, "Done", 1, 0, now)
	t1, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c1.ID,
		Position:  0,
		Title:     "One",
		Priority:  domain.PriorityLow,
	}, now)
	t2, _ := domain.NewTask(domain.TaskInput{
		ID:        "t2",
		ProjectID: p.ID,
		ColumnID:  c1.ID,
		Position:  1,
		Title:     "Two",
		Priority:  domain.PriorityLow,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c1, c2}, []domain.Task{t1, t2})
	m := loadReadyModel(t, NewModel(svc))

	m = applyMsg(t, m, tea.MouseWheelMsg{Button: tea.MouseWheelDown})
	if m.selectedTask != 1 {
		t.Fatalf("expected selectedTask=1 after wheel down, got %d", m.selectedTask)
	}

	clickX := m.columnWidth() + 5
	clickY := m.boardTop() + 2
	m = applyMsg(t, m, tea.MouseClickMsg{X: clickX, Y: clickY, Button: tea.MouseLeft})
	if m.selectedColumn != 1 {
		t.Fatalf("expected selectedColumn=1 after mouse click, got %d", m.selectedColumn)
	}
}

// TestModelBoardHidesSubtasksAndShowsProgress verifies board rows hide subtask cards but show progress metadata.
func TestModelBoardHidesSubtasksAndShowsProgress(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c1, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)

	parent, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-parent",
		ProjectID: p.ID,
		ColumnID:  c1.ID,
		Position:  0,
		Title:     "Parent task",
		Priority:  domain.PriorityMedium,
	}, now)
	childDone, _ := domain.NewTask(domain.TaskInput{
		ID:             "t-child-done",
		ProjectID:      p.ID,
		ColumnID:       c1.ID,
		Position:       1,
		Title:          "Child done",
		Priority:       domain.PriorityLow,
		Kind:           domain.WorkKindSubtask,
		ParentID:       parent.ID,
		LifecycleState: domain.StateDone,
	}, now)
	childTodo, _ := domain.NewTask(domain.TaskInput{
		ID:             "t-child-todo",
		ProjectID:      p.ID,
		ColumnID:       c1.ID,
		Position:       2,
		Title:          "Child todo",
		Priority:       domain.PriorityLow,
		Kind:           domain.WorkKindSubtask,
		ParentID:       parent.ID,
		LifecycleState: domain.StateTodo,
	}, now)

	svc := newFakeService([]domain.Project{p}, []domain.Column{c1}, []domain.Task{parent, childDone, childTodo})
	m := loadReadyModel(t, NewModel(svc))

	view := m.View()
	rendered := fmt.Sprint(view.Content)
	if strings.Contains(rendered, "Child done") || strings.Contains(rendered, "Child todo") {
		t.Fatalf("expected subtasks hidden from board rows, got\n%s", rendered)
	}
	if !strings.Contains(rendered, "[medium|1/2]") {
		t.Fatalf("expected subtask progress metadata in board row, got\n%s", rendered)
	}
}

// TestModelTaskInfoShowsSubtasksAcrossColumns verifies task-info modal subtask visibility independent of parent column.
func TestModelTaskInfoShowsSubtasksAcrossColumns(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	cTodo, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	cProgress, _ := domain.NewColumn("c2", p.ID, "In Progress", 1, 0, now)

	parent, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-parent",
		ProjectID: p.ID,
		ColumnID:  cProgress.ID,
		Position:  0,
		Title:     "Parent task",
		Priority:  domain.PriorityHigh,
	}, now)
	child, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-child",
		ProjectID: p.ID,
		ColumnID:  cTodo.ID,
		Position:  0,
		Title:     "Cross-column subtask",
		Priority:  domain.PriorityLow,
		Kind:      domain.WorkKindSubtask,
		ParentID:  parent.ID,
	}, now)

	svc := newFakeService([]domain.Project{p}, []domain.Column{cTodo, cProgress}, []domain.Task{parent, child})
	m := loadReadyModel(t, NewModel(svc))
	m.focusTaskByID(parent.ID)

	m = applyMsg(t, m, keyRune('i'))
	if m.mode != modeTaskInfo {
		t.Fatalf("expected task info mode, got %v", m.mode)
	}

	view := m.View()
	rendered := fmt.Sprint(view.Content)
	if !strings.Contains(rendered, "Cross-column subtask") {
		t.Fatalf("expected task info modal to include subtasks across columns, got\n%s", rendered)
	}
}

// TestModelTaskInfoEscStepsBack verifies esc navigates to parent before closing the task-info modal.
func TestModelTaskInfoEscStepsBack(t *testing.T) {
	now := time.Date(2026, 2, 22, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	cTodo, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	cProgress, _ := domain.NewColumn("c2", p.ID, "In Progress", 1, 0, now)

	parent, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-parent",
		ProjectID: p.ID,
		ColumnID:  cProgress.ID,
		Position:  0,
		Title:     "Parent task",
		Priority:  domain.PriorityHigh,
	}, now)
	child, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-child",
		ProjectID: p.ID,
		ColumnID:  cTodo.ID,
		Position:  0,
		Title:     "Nested subtask",
		Priority:  domain.PriorityLow,
		Kind:      domain.WorkKindSubtask,
		ParentID:  parent.ID,
	}, now)

	svc := newFakeService([]domain.Project{p}, []domain.Column{cTodo, cProgress}, []domain.Task{parent, child})
	m := loadReadyModel(t, NewModel(svc))
	m.focusTaskByID(parent.ID)

	m = applyMsg(t, m, keyRune('i'))
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter}) // drill into child
	if m.taskInfoTaskID != child.ID {
		t.Fatalf("expected drill-in to child task, got %q", m.taskInfoTaskID)
	}

	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEscape})
	if m.mode != modeTaskInfo {
		t.Fatalf("expected task-info mode after stepping back, got %v", m.mode)
	}
	if m.taskInfoTaskID != parent.ID {
		t.Fatalf("expected esc step-back to parent, got %q", m.taskInfoTaskID)
	}

	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEscape})
	if m.mode != modeNone {
		t.Fatalf("expected esc to close task-info at root, got %v", m.mode)
	}
}

// TestModelTaskInfoAllowsSubtaskCreation verifies task-info view can start a subtask form for the focused task.
func TestModelTaskInfoAllowsSubtaskCreation(t *testing.T) {
	now := time.Date(2026, 2, 23, 10, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	parent, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-parent",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Parent",
		Priority:  domain.PriorityMedium,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{parent})
	m := loadReadyModel(t, NewModel(svc))
	m.focusTaskByID(parent.ID)

	m = applyMsg(t, m, keyRune('i'))
	if m.mode != modeTaskInfo {
		t.Fatalf("expected task-info mode, got %v", m.mode)
	}
	m = applyMsg(t, m, keyRune('s'))
	if m.mode != modeAddTask {
		t.Fatalf("expected add-task mode after task-info subtask key, got %v", m.mode)
	}
	if got := m.taskFormKind; got != domain.WorkKindSubtask {
		t.Fatalf("expected subtask form kind, got %q", got)
	}
	if got := m.taskFormParentID; got != parent.ID {
		t.Fatalf("expected parent id %q, got %q", parent.ID, got)
	}
}

// TestModelTaskInfoMovesCurrentTaskWithBrackets verifies task-info mode supports moving the focused task between columns.
func TestModelTaskInfoMovesCurrentTaskWithBrackets(t *testing.T) {
	now := time.Date(2026, 2, 23, 10, 15, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	cTodo, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	cProgress, _ := domain.NewColumn("c2", p.ID, "In Progress", 1, 0, now)

	parent, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-parent",
		ProjectID: p.ID,
		ColumnID:  cTodo.ID,
		Position:  0,
		Title:     "Parent",
		Priority:  domain.PriorityMedium,
	}, now)
	child, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-child",
		ProjectID: p.ID,
		ColumnID:  cTodo.ID,
		Position:  1,
		Title:     "Child",
		Priority:  domain.PriorityLow,
		Kind:      domain.WorkKindSubtask,
		ParentID:  parent.ID,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{cTodo, cProgress}, []domain.Task{parent, child})
	m := loadReadyModel(t, NewModel(svc))
	m.focusTaskByID(parent.ID)

	m = applyMsg(t, m, keyRune('i'))
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter}) // open child from parent info
	if m.taskInfoTaskID != child.ID {
		t.Fatalf("expected child task info selected, got %q", m.taskInfoTaskID)
	}

	m = applyMsg(t, m, keyRune(']'))
	moved, ok := svc.taskByID(child.ID)
	if !ok {
		t.Fatalf("expected moved child task in fake service")
	}
	if moved.ColumnID != cProgress.ID {
		t.Fatalf("expected child moved to progress column %q, got %q", cProgress.ID, moved.ColumnID)
	}
	if m.mode != modeTaskInfo {
		t.Fatalf("expected task-info mode retained after move, got %v", m.mode)
	}

	m = applyMsg(t, m, keyRune('['))
	moved, ok = svc.taskByID(child.ID)
	if !ok {
		t.Fatalf("expected moved child task in fake service")
	}
	if moved.ColumnID != cTodo.ID {
		t.Fatalf("expected child moved back to todo column %q, got %q", cTodo.ID, moved.ColumnID)
	}
}

// TestModelTaskInfoSubtaskChecklistToggleCompletion verifies task-info checklist rendering and completion toggling.
func TestModelTaskInfoSubtaskChecklistToggleCompletion(t *testing.T) {
	now := time.Date(2026, 2, 23, 10, 20, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	cTodo, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	cProgress, _ := domain.NewColumn("c2", p.ID, "In Progress", 1, 0, now)
	cDone, _ := domain.NewColumn("c3", p.ID, "Done", 2, 0, now)

	parent, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-parent",
		ProjectID: p.ID,
		ColumnID:  cProgress.ID,
		Position:  0,
		Title:     "Parent",
		Priority:  domain.PriorityMedium,
	}, now)
	child, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-child",
		ProjectID: p.ID,
		ColumnID:  cTodo.ID,
		Position:  0,
		Title:     "Child",
		Priority:  domain.PriorityLow,
		Kind:      domain.WorkKindSubtask,
		ParentID:  parent.ID,
	}, now)

	svc := newFakeService([]domain.Project{p}, []domain.Column{cTodo, cProgress, cDone}, []domain.Task{parent, child})
	m := loadReadyModel(t, NewModel(svc))
	m.focusTaskByID(parent.ID)
	m = applyMsg(t, m, keyRune('i'))

	rendered := stripANSI(fmt.Sprint(m.View().Content))
	if !strings.Contains(rendered, "[ ] Child") {
		t.Fatalf("expected unchecked checklist row for subtask, got\n%s", rendered)
	}
	if !strings.Contains(rendered, "state:To Do") || !strings.Contains(rendered, "complete:no") {
		t.Fatalf("expected subtask state metadata in task-info checklist, got\n%s", rendered)
	}

	m = applyMsg(t, m, keyRune(' '))
	moved, ok := svc.taskByID(child.ID)
	if !ok {
		t.Fatalf("expected moved child task in fake service")
	}
	if moved.ColumnID != cDone.ID {
		t.Fatalf("expected checklist toggle to move child to done column %q, got %q", cDone.ID, moved.ColumnID)
	}

	rendered = stripANSI(fmt.Sprint(m.View().Content))
	if !strings.Contains(rendered, "[x] Child") {
		t.Fatalf("expected checked checklist row after completion toggle, got\n%s", rendered)
	}
	if !strings.Contains(rendered, "state:Done") || !strings.Contains(rendered, "complete:yes") {
		t.Fatalf("expected done state metadata after completion toggle, got\n%s", rendered)
	}

	m = applyMsg(t, m, keyRune(' '))
	moved, ok = svc.taskByID(child.ID)
	if !ok {
		t.Fatalf("expected moved child task in fake service")
	}
	if moved.ColumnID != cProgress.ID {
		t.Fatalf("expected reopening toggle to move child to progress column %q, got %q", cProgress.ID, moved.ColumnID)
	}
}

// TestModelBoardScrollKeepsSelectedRowVisible verifies dynamic list scrolling for long columns.
func TestModelBoardScrollKeepsSelectedRowVisible(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c1, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)

	tasks := make([]domain.Task, 0, 36)
	for i := 0; i < 36; i++ {
		task, _ := domain.NewTask(domain.TaskInput{
			ID:        fmt.Sprintf("t-%02d", i),
			ProjectID: p.ID,
			ColumnID:  c1.ID,
			Position:  i,
			Title:     fmt.Sprintf("Task %02d", i),
			Priority:  domain.PriorityLow,
		}, now)
		tasks = append(tasks, task)
	}

	svc := newFakeService([]domain.Project{p}, []domain.Column{c1}, tasks)
	m := loadReadyModel(t, NewModel(svc))
	for i := 0; i < 30; i++ {
		m = applyMsg(t, m, keyRune('j'))
	}

	view := m.View()
	rendered := fmt.Sprint(view.Content)
	if !strings.Contains(rendered, "Task 30") {
		t.Fatalf("expected selected row to remain visible after scrolling, got\n%s", rendered)
	}
}

// TestModelFocusedAndSelectedStyling verifies focused rows use fuchsia and retain multi-select cues.
func TestModelFocusedAndSelectedStyling(t *testing.T) {
	now := time.Date(2026, 2, 22, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Styled task",
		Priority:  domain.PriorityMedium,
	}, now)

	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task})
	m := loadReadyModel(t, NewModel(svc))
	m.selectedTaskIDs = map[string]struct{}{task.ID: {}}

	view := m.View()
	rendered := fmt.Sprint(view.Content)
	if !strings.Contains(rendered, "38;5;212") {
		t.Fatalf("expected focused task rendered with fuchsia color, got\n%s", rendered)
	}
	plain := stripANSI(rendered)
	if !strings.Contains(plain, "* Styled task") {
		t.Fatalf("expected focused+selected marker to preserve selection cue, got\n%s", plain)
	}
}

// TestModelSelectionMarkerOnlyOnTitleLine verifies marker symbols are not repeated on secondary card lines.
func TestModelSelectionMarkerOnlyOnTitleLine(t *testing.T) {
	now := time.Date(2026, 2, 23, 11, 30, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Has metadata line",
		Priority:  domain.PriorityMedium,
	}, now)

	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task})
	m := loadReadyModel(t, NewModel(svc))
	m.selectedTaskIDs = map[string]struct{}{task.ID: {}}

	plain := stripANSI(fmt.Sprint(m.View().Content))
	if strings.Count(plain, "* ") != 1 {
		t.Fatalf("expected exactly one focused+selected marker on title line, got\n%s", plain)
	}
}

// TestModelEscClearsSubtreeFocus verifies esc returns to full-board view from subtree focus.
func TestModelEscClearsSubtreeFocus(t *testing.T) {
	now := time.Date(2026, 2, 22, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c1, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	parent, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-parent",
		ProjectID: p.ID,
		ColumnID:  c1.ID,
		Position:  0,
		Title:     "Parent",
		Priority:  domain.PriorityMedium,
	}, now)
	child, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-child",
		ProjectID: p.ID,
		ColumnID:  c1.ID,
		Position:  1,
		Title:     "Child",
		Priority:  domain.PriorityLow,
		Kind:      domain.WorkKindSubtask,
		ParentID:  parent.ID,
	}, now)
	m := loadReadyModel(t, NewModel(newFakeService([]domain.Project{p}, []domain.Column{c1}, []domain.Task{parent, child})))
	m = applyMsg(t, m, keyRune('f'))
	if m.projectionRootTaskID == "" {
		t.Fatal("expected subtree focus root to be set")
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEscape})
	if m.projectionRootTaskID != "" {
		t.Fatalf("expected esc to clear subtree focus, got %q", m.projectionRootTaskID)
	}
	if m.status != "full board view" {
		t.Fatalf("expected full-board status, got %q", m.status)
	}
}

// TestModelQuitKey verifies behavior for the covered scenario.
func TestModelQuitKey(t *testing.T) {
	m := NewModel(newFakeService(nil, nil, nil))
	updated, cmd := m.Update(tea.KeyPressMsg{Code: 'q', Text: "q"})
	if updated == nil {
		t.Fatal("expected model return value")
	}
	if cmd == nil {
		t.Fatal("expected quit cmd")
	}
}

// TestModelViewStatesAndPrompts verifies behavior for the covered scenario.
func TestModelViewStatesAndPrompts(t *testing.T) {
	m := NewModel(newFakeService(nil, nil, nil))
	v := m.View()
	if v.Content == nil || v.MouseMode != tea.MouseModeCellMotion {
		t.Fatal("expected loading view with mouse enabled")
	}

	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, nil)
	m = loadReadyModel(t, NewModel(svc))
	m.mode = modeAddTask
	m.input = "abc"
	if !strings.Contains(m.modePrompt(), "new task title") {
		t.Fatal("expected add mode prompt")
	}

	m.err = context.DeadlineExceeded
	v = m.View()
	if v.Content == nil {
		t.Fatal("expected error view content")
	}
}

// TestModelNoProjectsKeepsPickerAndCreationFlow verifies first-run picker flow remains usable for creation.
func TestModelNoProjectsKeepsPickerAndCreationFlow(t *testing.T) {
	m := loadReadyModel(t, NewModel(newFakeService(nil, nil, nil)))
	if m.mode != modeProjectPicker {
		t.Fatalf("expected project-picker mode for empty workspace, got %v", m.mode)
	}
	view := m.View()
	rendered := fmt.Sprint(view.Content)
	if !strings.Contains(rendered, "Projects") || !strings.Contains(rendered, "N new project") {
		t.Fatalf("expected project-picker overlay with create action, got\n%s", rendered)
	}

	m = applyMsg(t, m, keyRune('N'))
	if m.mode != modeAddProject {
		t.Fatalf("expected add-project mode after picker new-project action, got %v", m.mode)
	}
}

// TestModelLaunchStartsInProjectPicker verifies first launch opens the project picker before normal mode.
func TestModelLaunchStartsInProjectPicker(t *testing.T) {
	now := time.Date(2026, 2, 23, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, nil)

	initial := NewModel(svc, WithLaunchProjectPicker(true))
	ready := applyMsg(t, applyCmd(t, initial, initial.Init()), tea.WindowSizeMsg{Width: 120, Height: 40})
	if ready.mode != modeProjectPicker {
		t.Fatalf("expected launch picker mode, got %v", ready.mode)
	}
	if ready.projectPickerIndex != 0 {
		t.Fatalf("expected picker index 0 on launch, got %d", ready.projectPickerIndex)
	}
}

// TestModelStartupBootstrapPrecedesLaunchPicker verifies startup bootstrap modal ordering and completion.
func TestModelStartupBootstrapPrecedesLaunchPicker(t *testing.T) {
	now := time.Date(2026, 2, 23, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, nil)

	root := t.TempDir()
	saveCalls := 0
	var saved BootstrapConfig
	initial := NewModel(
		svc,
		WithLaunchProjectPicker(true),
		WithStartupBootstrap(true),
		WithSaveBootstrapConfigCallback(func(cfg BootstrapConfig) error {
			saveCalls++
			saved = cfg
			return nil
		}),
	)
	ready := applyMsg(t, applyCmd(t, initial, initial.Init()), tea.WindowSizeMsg{Width: 120, Height: 40})
	if ready.mode != modeBootstrapSettings {
		t.Fatalf("expected startup bootstrap mode, got %v", ready.mode)
	}
	ready = applyMsg(t, ready, tea.KeyPressMsg{Code: tea.KeyEscape})
	if ready.mode != modeBootstrapSettings {
		t.Fatalf("expected mandatory bootstrap modal to ignore esc, got %v", ready.mode)
	}

	ready.bootstrapDisplayInput.SetValue("Lane User")
	ready.bootstrapActorIndex = bootstrapActorTypeIndex("agent")
	ready.bootstrapRoots = []string{root}
	ready.bootstrapFocus = 2
	ready = applyMsg(t, ready, tea.KeyPressMsg{Code: tea.KeyEnter})
	if saveCalls != 1 {
		t.Fatalf("expected one bootstrap save call, got %d", saveCalls)
	}
	if saved.DisplayName != "Lane User" || saved.DefaultActorType != "user" {
		t.Fatalf("unexpected saved bootstrap config %#v", saved)
	}
	if ready.mode != modeProjectPicker {
		t.Fatalf("expected project picker after bootstrap save, got %v", ready.mode)
	}
}

// TestModelBootstrapSettingsCommandPaletteRootsEditing verifies command-palette bootstrap settings editing and fuzzy root add.
func TestModelBootstrapSettingsCommandPaletteRootsEditing(t *testing.T) {
	now := time.Date(2026, 2, 23, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Task",
		Priority:  domain.PriorityMedium,
	}, now)
	rootA := t.TempDir()
	rootB := t.TempDir()
	if err := os.WriteFile(filepath.Join(rootB, "notes.txt"), []byte("ok"), 0o644); err != nil {
		t.Fatalf("WriteFile() error = %v", err)
	}

	saveCalls := 0
	var saved BootstrapConfig
	m := loadReadyModel(t, NewModel(
		newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task}),
		WithIdentityConfig(IdentityConfig{
			DisplayName:      "Lane User",
			DefaultActorType: "user",
		}),
		WithSearchRoots([]string{rootA}),
		WithSaveBootstrapConfigCallback(func(cfg BootstrapConfig) error {
			saveCalls++
			saved = cfg
			return nil
		}),
	))
	m.defaultRootDir = rootB

	updated, cmd := m.executeCommandPalette("bootstrap-settings")
	m = applyResult(t, updated, cmd)
	if m.mode != modeBootstrapSettings {
		t.Fatalf("expected bootstrap settings mode from command palette, got %v", m.mode)
	}
	if got := m.bootstrapDisplayInput.Value(); got != "Lane User" {
		t.Fatalf("expected display name prefill Lane User, got %q", got)
	}
	if len(m.bootstrapRoots) != 1 || m.bootstrapRoots[0] != filepath.Clean(rootA) {
		t.Fatalf("expected root prefill %q, got %#v", filepath.Clean(rootA), m.bootstrapRoots)
	}

	m = applyCmd(t, m, m.focusBootstrapField(1))
	m = applyMsg(t, m, keyRune('d'))
	if len(m.bootstrapRoots) != 0 {
		t.Fatalf("expected root removal from bootstrap modal, got %#v", m.bootstrapRoots)
	}

	m = applyMsg(t, m, tea.KeyPressMsg{Code: 'r', Mod: tea.ModCtrl})
	if m.mode != modeResourcePicker {
		t.Fatalf("expected resource picker for bootstrap root browse, got %v", m.mode)
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: 'a', Mod: tea.ModCtrl})
	if m.mode != modeBootstrapSettings {
		t.Fatalf("expected return to bootstrap modal after root attach, got %v", m.mode)
	}
	if len(m.bootstrapRoots) != 1 || m.bootstrapRoots[0] != filepath.Clean(rootB) {
		t.Fatalf("expected root picker add %q, got %#v", filepath.Clean(rootB), m.bootstrapRoots)
	}
	m = applyCmd(t, m, m.focusBootstrapField(1))
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyDown})
	if m.bootstrapFocus != 2 {
		t.Fatalf("expected down arrow on roots to continue focus navigation, got %d", m.bootstrapFocus)
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyUp})
	if m.bootstrapFocus != 1 {
		t.Fatalf("expected up arrow to return focus to roots, got %d", m.bootstrapFocus)
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyUp})
	if m.bootstrapFocus != 0 {
		t.Fatalf("expected up arrow on first root row to move focus backward, got %d", m.bootstrapFocus)
	}

	m.bootstrapDisplayInput.SetValue("Lane Agent")
	m.bootstrapActorIndex = bootstrapActorTypeIndex("system")
	m = applyCmd(t, m, m.focusBootstrapField(2))
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if saveCalls != 1 {
		t.Fatalf("expected one bootstrap save call, got %d", saveCalls)
	}
	if m.mode != modeNone {
		t.Fatalf("expected bootstrap modal to close after save, got %v", m.mode)
	}
	if m.identityDisplayName != "Lane Agent" || m.identityDefaultActorType != "system" {
		t.Fatalf("expected in-memory bootstrap settings update, got name=%q actor=%q", m.identityDisplayName, m.identityDefaultActorType)
	}
	if len(m.searchRoots) != 1 || m.searchRoots[0] != filepath.Clean(rootB) {
		t.Fatalf("expected in-memory search roots update %q, got %#v", filepath.Clean(rootB), m.searchRoots)
	}
	if saved.DisplayName != "Lane Agent" || saved.DefaultActorType != "system" {
		t.Fatalf("unexpected callback bootstrap payload %#v", saved)
	}
}

// TestModelInputModePaths verifies behavior for the covered scenario.
func TestModelInputModePaths(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Task",
		Priority:  domain.PriorityLow,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task})
	m := loadReadyModel(t, NewModel(svc))

	m = applyMsg(t, m, keyRune('n'))
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyBackspace})
	if m.mode != modeAddTask {
		t.Fatalf("expected add mode, got %v", m.mode)
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEscape})
	if m.mode != modeNone {
		t.Fatalf("expected modeNone after escape, got %v", m.mode)
	}

	m = applyMsg(t, m, keyRune('n'))
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter}) // empty submit
	if !strings.Contains(m.status, "title required") {
		t.Fatalf("expected title required status, got %q", m.status)
	}

	m = applyMsg(t, m, keyRune('/'))
	m = applyMsg(t, m, keyRune('T'))
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if m.searchQuery != "T" {
		t.Fatalf("expected search query set, got %q", m.searchQuery)
	}

	m = applyMsg(t, m, keyRune('e'))
	m.input = "Task 2 | expanded details | high | 2026-03-01 | alpha,beta"
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if !strings.Contains(svc.tasks[p.ID][0].Title, "Task 2") {
		t.Fatalf("expected edited title, got %q", svc.tasks[p.ID][0].Title)
	}
	if svc.tasks[p.ID][0].Priority != domain.PriorityHigh || len(svc.tasks[p.ID][0].Labels) != 2 {
		t.Fatalf("expected full-field update, got %#v", svc.tasks[p.ID][0])
	}
}

// TestModelNormalModeExtraBranches verifies behavior for the covered scenario.
func TestModelNormalModeExtraBranches(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p1, _ := domain.NewProject("p1", "A", "", now)
	p2, _ := domain.NewProject("p2", "B", "", now)
	c1, _ := domain.NewColumn("c1", p1.ID, "To Do", 0, 0, now)
	c2, _ := domain.NewColumn("c2", p2.ID, "To Do", 0, 0, now)
	t1, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p1.ID,
		ColumnID:  c1.ID,
		Position:  0,
		Title:     "Alpha",
		Priority:  domain.PriorityLow,
	}, now)
	svc := newFakeService([]domain.Project{p1, p2}, []domain.Column{c1, c2}, []domain.Task{t1})
	m := loadReadyModel(t, NewModel(svc))

	m = applyMsg(t, m, keyRune('t'))
	if !m.showArchived {
		t.Fatal("expected showArchived enabled")
	}
	m = applyMsg(t, m, keyRune('t'))
	if m.showArchived {
		t.Fatal("expected showArchived disabled")
	}

	m = applyMsg(t, m, keyRune('u'))
	if !strings.Contains(m.status, "nothing to restore") {
		t.Fatalf("expected restore status, got %q", m.status)
	}

	m.searchQuery = "x"
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEscape})
	if m.searchQuery != "" {
		t.Fatalf("expected search cleared, got %q", m.searchQuery)
	}

	m = applyMsg(t, m, keyRune('P'))
	if m.selectedProject != 0 {
		t.Fatalf("expected selection unchanged in picker-open path, got %d", m.selectedProject)
	}
	if m.mode != modeProjectPicker {
		t.Fatalf("expected project picker mode, got %v", m.mode)
	}

	// out of range move left should no-op
	m.mode = modeNone
	m.selectedColumn = 0
	m = applyMsg(t, m, keyRune('['))
	if m.selectedColumn != 0 {
		t.Fatalf("expected no-op move left, got %d", m.selectedColumn)
	}
}

// TestModelBulkMoveKeysUseSelection verifies that bracket move keys apply to the full multi-selection.
func TestModelBulkMoveKeysUseSelection(t *testing.T) {
	now := time.Date(2026, 2, 22, 12, 0, 0, 0, time.UTC)
	project, _ := domain.NewProject("p1", "Inbox", "", now)
	todo, _ := domain.NewColumn("c1", project.ID, "To Do", 0, 0, now)
	progress, _ := domain.NewColumn("c2", project.ID, "In Progress", 1, 0, now)

	t1, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: project.ID,
		ColumnID:  todo.ID,
		Position:  0,
		Title:     "Task 1",
		Priority:  domain.PriorityMedium,
	}, now)
	t2, _ := domain.NewTask(domain.TaskInput{
		ID:        "t2",
		ProjectID: project.ID,
		ColumnID:  todo.ID,
		Position:  1,
		Title:     "Task 2",
		Priority:  domain.PriorityMedium,
	}, now)

	svc := newFakeService([]domain.Project{project}, []domain.Column{todo, progress}, []domain.Task{t1, t2})
	m := loadReadyModel(t, NewModel(svc))
	m.selectedTaskIDs = map[string]struct{}{"t1": {}, "t2": {}}

	m = applyMsg(t, m, keyRune(']'))

	moved := map[string]string{}
	for _, task := range svc.tasks[project.ID] {
		moved[task.ID] = task.ColumnID
	}
	if moved["t1"] != progress.ID || moved["t2"] != progress.ID {
		t.Fatalf("expected both selected tasks moved to progress column, got %#v", moved)
	}
}

// TestHelpersCoverage verifies behavior for the covered scenario.
func TestHelpersCoverage(t *testing.T) {
	if clamp(5, 0, 1) != 1 {
		t.Fatal("clamp upper bound failed")
	}
	if clamp(-1, 0, 1) != 0 {
		t.Fatal("clamp lower bound failed")
	}
	if clamp(0, 2, 1) != 2 {
		t.Fatal("clamp invalid range failed")
	}
	if truncate("abc", 0) != "" {
		t.Fatal("truncate max 0 failed")
	}
	if truncate("abc", 1) != "a" {
		t.Fatal("truncate max 1 failed")
	}
	if truncate("abcdef", 3) != "ab" {
		t.Fatal("truncate ellipsis failed")
	}
	if summarizeLabels([]string{"a", "b", "c"}, 2) != "#a,#b+1" {
		t.Fatalf("unexpected label summary %q", summarizeLabels([]string{"a", "b", "c"}, 2))
	}

	m := Model{}
	if m.modeLabel() != "normal" {
		t.Fatalf("mode label mismatch: %q", m.modeLabel())
	}
	m.mode = modeAddTask
	if !strings.Contains(m.modePrompt(), "new task title") {
		t.Fatal("expected add mode prompt")
	}
	m.mode = modeSearch
	if !strings.Contains(m.modePrompt(), "search query") {
		t.Fatal("expected search mode prompt")
	}
	m.mode = modeRenameTask
	if !strings.Contains(m.modePrompt(), "rename task") {
		t.Fatal("expected rename mode prompt")
	}
	m.mode = modeEditTask
	if !strings.Contains(m.modePrompt(), "title | description") {
		t.Fatal("expected edit mode prompt")
	}
	m.mode = modeProjectPicker
	if !strings.Contains(m.modePrompt(), "project picker") {
		t.Fatal("expected picker mode prompt")
	}
	m.mode = modeTaskInfo
	if !strings.Contains(m.modePrompt(), "task info") {
		t.Fatal("expected task info mode prompt")
	}
	m.mode = modeAddProject
	if !strings.Contains(m.modePrompt(), "new project") {
		t.Fatal("expected add project mode prompt")
	}
	m.mode = modeEditProject
	if !strings.Contains(m.modePrompt(), "edit project") {
		t.Fatal("expected edit project mode prompt")
	}
	m.mode = modeSearchResults
	if !strings.Contains(m.modePrompt(), "search results") {
		t.Fatal("expected search results mode prompt")
	}
	m.mode = modeCommandPalette
	if !strings.Contains(m.modePrompt(), "command palette") {
		t.Fatal("expected command palette mode prompt")
	}
	m.mode = modeQuickActions
	if !strings.Contains(m.modePrompt(), "quick actions") {
		t.Fatal("expected quick actions mode prompt")
	}
	m.mode = modeThread
	if !strings.Contains(m.modePrompt(), "thread:") {
		t.Fatal("expected thread mode prompt")
	}

	m.columns = []domain.Column{{ID: "c1"}}
	m.width = 10
	if m.columnWidth() < 18 {
		t.Fatal("expected minimum width")
	}
	m.width = 300
	if m.columnWidth() > 42 {
		t.Fatal("expected maximum width")
	}
}

// TestTaskEditParsing verifies behavior for the covered scenario.
func TestTaskEditParsing(t *testing.T) {
	now := time.Date(2026, 2, 21, 0, 0, 0, 0, time.UTC)
	current, _ := domain.NewTask(domain.TaskInput{
		ID:          "t1",
		ProjectID:   "p1",
		ColumnID:    "c1",
		Position:    0,
		Title:       "old",
		Description: "desc",
		Priority:    domain.PriorityMedium,
		DueAt:       &now,
		Labels:      []string{"x"},
	}, now)

	input, err := parseTaskEditInput("new | details | high | 2026-03-01 | a,b", current)
	if err != nil {
		t.Fatalf("parseTaskEditInput() error = %v", err)
	}
	if input.Title != "new" || input.Priority != domain.PriorityHigh {
		t.Fatalf("unexpected parsed input %#v", input)
	}
	if input.DueAt == nil || input.DueAt.Format("2006-01-02") != "2026-03-01" {
		t.Fatalf("unexpected parsed due date %#v", input.DueAt)
	}

	_, err = parseTaskEditInput("x | y | urgent | - | -", current)
	if err == nil {
		t.Fatal("expected invalid priority error")
	}
	_, err = parseTaskEditInput("x | y | low | 03/01/2026 | -", current)
	if err == nil {
		t.Fatal("expected invalid date error")
	}

	if !strings.Contains(formatTaskEditInput(current), "old") {
		t.Fatal("expected formatter to include title")
	}
}

// TestProjectPickerMouseAndWheel verifies behavior for the covered scenario.
func TestProjectPickerMouseAndWheel(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p1, _ := domain.NewProject("p1", "A", "", now)
	p2, _ := domain.NewProject("p2", "B", "", now)
	c1, _ := domain.NewColumn("c1", p1.ID, "To Do", 0, 0, now)
	c2, _ := domain.NewColumn("c2", p2.ID, "To Do", 0, 0, now)
	svc := newFakeService([]domain.Project{p1, p2}, []domain.Column{c1, c2}, nil)
	m := loadReadyModel(t, NewModel(svc))

	m = applyMsg(t, m, keyRune('p'))
	m = applyMsg(t, m, tea.MouseWheelMsg{Button: tea.MouseWheelDown})
	if m.projectPickerIndex != 1 {
		t.Fatalf("expected wheel to move picker, got %d", m.projectPickerIndex)
	}
	m = applyMsg(t, m, tea.MouseClickMsg{X: 2, Y: 7, Button: tea.MouseLeft})
	if m.projectPickerIndex != 1 {
		t.Fatalf("expected click to target second project, got %d", m.projectPickerIndex)
	}
}

// TestTaskFieldConfigAffectsRendering verifies behavior for the covered scenario.
func TestTaskFieldConfigAffectsRendering(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	due := now.Add(24 * time.Hour)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:          "t1",
		ProjectID:   p.ID,
		ColumnID:    c.ID,
		Position:    0,
		Title:       "Task",
		Description: "detailed notes",
		Priority:    domain.PriorityHigh,
		DueAt:       &due,
		Labels:      []string{"one", "two", "three"},
	}, now)

	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task})
	mDefault := loadReadyModel(t, NewModel(svc))
	meta := mDefault.cardMeta(task)
	if !strings.Contains(meta, "high") || !strings.Contains(meta, "#one,#three+1") {
		t.Fatalf("expected default card meta with priority and labels, got %q", meta)
	}

	mHidden := loadReadyModel(t, NewModel(svc, WithTaskFieldConfig(TaskFieldConfig{
		ShowPriority:    false,
		ShowDueDate:     false,
		ShowLabels:      false,
		ShowDescription: false,
	})))
	if mHidden.cardMeta(task) != "" {
		t.Fatalf("expected empty card meta when all card fields hidden, got %q", mHidden.cardMeta(task))
	}
	details := mHidden.renderTaskDetails(lipgloss.Color("212"), lipgloss.Color("245"), lipgloss.Color("241"))
	if strings.Contains(details, "priority:") || strings.Contains(details, "due:") || strings.Contains(details, "labels:") {
		t.Fatalf("expected details metadata hidden, got %q", details)
	}
	if strings.Contains(details, "detailed notes") {
		t.Fatalf("expected description hidden, got %q", details)
	}
}

// TestDeleteUsesConfiguredDefaultMode verifies behavior for the covered scenario.
func TestDeleteUsesConfiguredDefaultMode(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	t1, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "One",
		Priority:  domain.PriorityLow,
	}, now)
	t2, _ := domain.NewTask(domain.TaskInput{
		ID:        "t2",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  1,
		Title:     "Two",
		Priority:  domain.PriorityLow,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{t1, t2})

	m := loadReadyModel(t, NewModel(svc, WithDefaultDeleteMode(app.DeleteModeHard)))
	m = applyMsg(t, m, keyRune('d'))
	if m.mode != modeConfirmAction {
		t.Fatalf("expected confirm mode for default hard delete, got %v", m.mode)
	}
	m.confirmChoice = 0
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if len(svc.tasks[p.ID]) != 1 {
		t.Fatalf("expected default delete mode hard to remove selected task, got %d", len(svc.tasks[p.ID]))
	}
}

// TestParseDueAndLabelsInput verifies behavior for the covered scenario.
func TestParseDueAndLabelsInput(t *testing.T) {
	now := time.Date(2026, 2, 21, 0, 0, 0, 0, time.UTC)

	gotDue, err := parseDueInput("", &now)
	if err != nil {
		t.Fatalf("parseDueInput empty unexpected error: %v", err)
	}
	if gotDue == nil || !gotDue.Equal(now) {
		t.Fatalf("expected current due date to be preserved, got %#v", gotDue)
	}

	gotDue, err = parseDueInput("-", &now)
	if err != nil {
		t.Fatalf("parseDueInput dash unexpected error: %v", err)
	}
	if gotDue != nil {
		t.Fatalf("expected due date cleared, got %#v", gotDue)
	}

	gotDue, err = parseDueInput("2026-03-01", nil)
	if err != nil {
		t.Fatalf("parseDueInput valid unexpected error: %v", err)
	}
	if gotDue == nil || gotDue.Format("2006-01-02") != "2026-03-01" {
		t.Fatalf("expected parsed due date, got %#v", gotDue)
	}
	gotDue, err = parseDueInput("2026-03-01T15:04", nil)
	if err != nil {
		t.Fatalf("parseDueInput datetime unexpected error: %v", err)
	}
	if gotDue == nil || gotDue.In(time.Local).Hour() != 15 || gotDue.In(time.Local).Minute() != 4 {
		t.Fatalf("expected parsed due datetime, got %#v", gotDue)
	}

	if _, err = parseDueInput("03/01/2026", nil); err == nil {
		t.Fatal("expected parseDueInput invalid format error")
	}

	currentLabels := []string{"one"}
	if got := parseLabelsInput("", currentLabels); len(got) != 1 || got[0] != "one" {
		t.Fatalf("expected current labels preserved, got %#v", got)
	}
	if got := parseLabelsInput("-", currentLabels); got != nil {
		t.Fatalf("expected labels cleared with -, got %#v", got)
	}
	if got := parseLabelsInput("a, b, , c", nil); len(got) != 3 || got[0] != "a" || got[2] != "c" {
		t.Fatalf("expected parsed labels, got %#v", got)
	}

	if got := canonicalSearchStates([]string{}); len(got) != 4 || got[0] != "todo" {
		t.Fatalf("expected state fallback, got %#v", got)
	}
	if got := canonicalSearchStates([]string{"todo", "progress", "todo"}); len(got) != 2 || got[1] != "progress" {
		t.Fatalf("expected deduped state filters, got %#v", got)
	}
	if got := canonicalSearchStates([]string{"unknown"}); len(got) != 4 || got[0] != "todo" {
		t.Fatalf("expected canonical fallback for unknown states, got %#v", got)
	}
}

// TestRenderModeOverlayAndIndexHelpers verifies behavior for the covered scenario.
func TestRenderModeOverlayAndIndexHelpers(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c1, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	c2, _ := domain.NewColumn("c2", p.ID, "Done", 1, 0, now)
	t1, _ := domain.NewTask(domain.TaskInput{
		ID:          "t1",
		ProjectID:   p.ID,
		ColumnID:    c1.ID,
		Position:    0,
		Title:       "First",
		Description: "desc one",
		Priority:    domain.PriorityLow,
	}, now)
	t2, _ := domain.NewTask(domain.TaskInput{
		ID:        "t2",
		ProjectID: p.ID,
		ColumnID:  c1.ID,
		Position:  1,
		Title:     "Second",
		Priority:  domain.PriorityHigh,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c1, c2}, []domain.Task{t1, t2})
	m := loadReadyModel(t, NewModel(svc))

	accent := lipgloss.Color("62")
	muted := lipgloss.Color("241")
	dim := lipgloss.Color("239")
	helpStyle := lipgloss.NewStyle().Foreground(muted)

	projectPicker := m
	projectPicker.mode = modeProjectPicker
	projectPicker.projectPickerIndex = 0
	if out := projectPicker.renderModeOverlay(accent, muted, dim, helpStyle, 80); !strings.Contains(out, "Projects") {
		t.Fatalf("expected project picker overlay, got %q", out)
	}

	addMode := m
	_ = addMode.startTaskForm(nil)
	if out := addMode.renderModeOverlay(accent, muted, dim, helpStyle, 80); !strings.Contains(out, "New Task") || !strings.Contains(out, "title:") {
		t.Fatalf("expected add-task overlay with fields, got %q", out)
	}
	if out := addMode.renderModeOverlay(accent, muted, dim, helpStyle, 80); strings.Contains(out, "fields: title") {
		t.Fatalf("expected simplified modal hints without repeated fields legend, got %q", out)
	}

	task, ok := m.selectedTaskInCurrentColumn()
	if !ok {
		t.Fatal("expected selected task")
	}
	editMode := m
	_ = editMode.startTaskForm(&task)
	if out := editMode.renderModeOverlay(accent, muted, dim, helpStyle, 80); !strings.Contains(out, "Edit Task") {
		t.Fatalf("expected edit overlay, got %q", out)
	}

	searchMode := m
	_ = searchMode.startSearchMode()
	if out := searchMode.renderModeOverlay(accent, muted, dim, helpStyle, 80); !strings.Contains(out, "Search") {
		t.Fatalf("expected search overlay, got %q", out)
	}
	searchMode.mode = modeSearchResults
	searchMode.searchMatches = []app.TaskMatch{{Project: p, Task: t1, StateID: "todo"}}
	if out := searchMode.renderModeOverlay(accent, muted, dim, helpStyle, 80); !strings.Contains(out, "Search Results") {
		t.Fatalf("expected search-results overlay, got %q", out)
	}

	renameMode := m
	renameMode.mode = modeRenameTask
	renameMode.input = "rename me"
	if out := renameMode.renderModeOverlay(accent, muted, dim, helpStyle, 80); !strings.Contains(out, "Rename Task") {
		t.Fatalf("expected rename overlay, got %q", out)
	}
	infoMode := m
	infoMode.mode = modeTaskInfo
	if out := infoMode.renderModeOverlay(accent, muted, dim, helpStyle, 80); !strings.Contains(out, "Task Info") {
		t.Fatalf("expected task info overlay, got %q", out)
	}

	projectMode := m
	_ = projectMode.startProjectForm(nil)
	if out := projectMode.renderModeOverlay(accent, muted, dim, helpStyle, 80); !strings.Contains(out, "New Project") {
		t.Fatalf("expected project overlay, got %q", out)
	}

	commandMode := m
	_ = commandMode.startCommandPalette()
	if out := commandMode.renderModeOverlay(accent, muted, dim, helpStyle, 80); !strings.Contains(out, "Command Palette") {
		t.Fatalf("expected command palette overlay, got %q", out)
	}

	actionMode := m
	_ = actionMode.startQuickActions()
	if out := actionMode.renderModeOverlay(accent, muted, dim, helpStyle, 80); !strings.Contains(out, "Quick Actions") {
		t.Fatalf("expected quick actions overlay, got %q", out)
	}

	tasks := m.currentColumnTasks()
	if idx := m.taskIndexAtRow(tasks, 0); idx != 0 {
		t.Fatalf("expected row 0 => task 0, got %d", idx)
	}
	if idx := m.taskIndexAtRow(tasks, 3); idx != 1 {
		t.Fatalf("expected row 3 => task 1, got %d", idx)
	}
	if idx := m.taskIndexAtRow(tasks, 99); idx != 1 {
		t.Fatalf("expected large row => last task, got %d", idx)
	}

	panelWithSelection := m.renderOverviewPanel(p, accent, muted, dim, 30, 0, 0, 0, nil)
	if !strings.Contains(panelWithSelection, "Selection") {
		t.Fatalf("expected overview panel selection section, got %q", panelWithSelection)
	}
	noneSelected := m
	noneSelected.selectedColumn = 1
	panelWithoutSelection := noneSelected.renderOverviewPanel(p, accent, muted, dim, 30, 0, 0, 0, nil)
	if !strings.Contains(panelWithoutSelection, "no task selected") {
		t.Fatalf("expected overview panel no-selection hint, got %q", panelWithoutSelection)
	}
}

// TestModelFormValidationPaths verifies behavior for the covered scenario.
func TestModelFormValidationPaths(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	existing, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Existing",
		Priority:  domain.PriorityLow,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{existing})
	m := loadReadyModel(t, NewModel(svc))

	// Add mode: invalid priority branch.
	m = applyMsg(t, m, keyRune('n'))
	m.formInputs[0].SetValue("Draft roadmap")
	m.formInputs[2].SetValue("urgent")
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if !strings.Contains(m.status, "priority must be low|medium|high") {
		t.Fatalf("expected invalid priority status, got %q", m.status)
	}

	// Add mode: invalid due date branch.
	m.formInputs[2].SetValue("high")
	m.formInputs[3].SetValue("03/01/2026")
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if !strings.Contains(m.status, "due date must be YYYY-MM-DD") {
		t.Fatalf("expected invalid due status, got %q", m.status)
	}

	// Add mode: success path.
	m.formInputs[3].SetValue("2026-03-01")
	m.formInputs[4].SetValue("planning,kan")
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if len(svc.tasks[p.ID]) != 2 {
		t.Fatalf("expected create task success, got %d tasks", len(svc.tasks[p.ID]))
	}

	// Edit mode: invalid priority branch.
	m.selectedTask = 0
	m = applyMsg(t, m, keyRune('e'))
	m.formInputs[2].SetValue("invalid")
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if !strings.Contains(m.status, "priority must be low|medium|high") {
		t.Fatalf("expected invalid edit priority status, got %q", m.status)
	}
}

// TestTaskInfoModeAndPriorityPicker verifies behavior for the covered scenario.
func TestTaskInfoModeAndPriorityPicker(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Task",
		Priority:  domain.PriorityMedium,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task})
	m := loadReadyModel(t, NewModel(svc))

	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if m.mode != modeTaskInfo {
		t.Fatalf("expected enter to open task info mode, got %v", m.mode)
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEscape})
	if m.mode != modeNone {
		t.Fatalf("expected esc to close task info mode, got %v", m.mode)
	}

	m = applyMsg(t, m, keyRune('i'))
	if m.mode != modeTaskInfo {
		t.Fatalf("expected task info mode, got %v", m.mode)
	}
	m = applyMsg(t, m, keyRune('e'))
	if m.mode != modeEditTask {
		t.Fatalf("expected edit mode from task info, got %v", m.mode)
	}

	m.formFocus = 2
	before := m.formInputs[2].Value()
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyRight})
	after := m.formInputs[2].Value()
	if before == after {
		t.Fatalf("expected priority picker value to change, still %q", after)
	}
	changed := m.formInputs[2].Value()
	m = applyMsg(t, m, keyRune('x'))
	if m.formInputs[2].Value() != changed {
		t.Fatalf("expected typing ignored on priority picker, got %q", m.formInputs[2].Value())
	}
}

// TestTaskFormDuePickerFlow verifies behavior for the covered scenario.
func TestTaskFormDuePickerFlow(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, nil)
	m := loadReadyModel(t, NewModel(svc))

	m = applyMsg(t, m, keyRune('n'))
	if m.mode != modeAddTask {
		t.Fatalf("expected add task mode, got %v", m.mode)
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyTab})
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyTab})
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyTab})
	if m.formFocus != 3 {
		t.Fatalf("expected due field focus, got %d", m.formFocus)
	}
	dueOverlay := m.renderModeOverlay(lipgloss.Color("62"), lipgloss.Color("241"), lipgloss.Color("239"), lipgloss.NewStyle(), 96)
	if !strings.Contains(dueOverlay, "YYYY-MM-DD HH:MM") || !strings.Contains(dueOverlay, "RFC3339") || !strings.Contains(dueOverlay, "local time") {
		t.Fatalf("expected explicit due datetime format hints, got %q", dueOverlay)
	}

	m = applyMsg(t, m, keyRune('D'))
	if m.mode != modeDuePicker {
		t.Fatalf("expected due picker mode, got %v", m.mode)
	}

	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if m.mode != modeAddTask {
		t.Fatalf("expected return to add task mode, got %v", m.mode)
	}
	if got := strings.TrimSpace(m.formInputs[3].Value()); got != "-" {
		t.Fatalf("expected due field to be '-', got %q", got)
	}

	m = applyMsg(t, m, keyRune('D'))
	m = applyMsg(t, m, keyRune('j'))
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	due := strings.TrimSpace(m.formInputs[3].Value())
	if len(due) != 10 || strings.Count(due, "-") != 2 {
		t.Fatalf("expected YYYY-MM-DD due value, got %q", due)
	}
}

// TestDuePickerTypedInputAndFocusControls verifies typed date/time options and focus transitions.
func TestDuePickerTypedInputAndFocusControls(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	m := loadReadyModel(t, NewModel(newFakeService([]domain.Project{p}, []domain.Column{c}, nil)))

	m = applyMsg(t, m, keyRune('n'))
	if m.mode != modeAddTask {
		t.Fatalf("expected add task mode, got %v", m.mode)
	}
	m.formFocus = taskFieldDue
	m.startDuePicker()
	if m.mode != modeDuePicker {
		t.Fatalf("expected due picker mode, got %v", m.mode)
	}

	m.duePickerIncludeTime = true
	m.duePickerDateInput.SetValue(time.Now().In(time.Local).Format("2006-01-02"))
	m.duePickerTimeInput.SetValue("17:45")
	options := m.duePickerOptions()
	if len(options) == 0 || !strings.Contains(strings.ToLower(options[0].Label), "use typed datetime") {
		t.Fatalf("expected typed datetime option at top, got %#v", options)
	}
	if !strings.HasSuffix(options[0].Value, "17:45") {
		t.Fatalf("expected typed datetime value to include 17:45, got %q", options[0].Value)
	}

	m.duePickerFocus = 2
	_ = m.setDuePickerIncludeTime(false)
	if m.duePickerFocus != 3 {
		t.Fatalf("expected focus to move from time input to list when time disabled, got %d", m.duePickerFocus)
	}
	if got := m.duePickerFocusSlots(); len(got) != 3 {
		t.Fatalf("expected three focus slots without time input, got %#v", got)
	}

	if _, ok := resolveDuePickerDateToken("today", time.Now().In(time.Local)); !ok {
		t.Fatal("expected today token to parse")
	}
	if hour, minute, ok := parseDuePickerTimeToken("5:30pm"); !ok || hour != 17 || minute != 30 {
		t.Fatalf("expected 5:30pm parse to 17:30, got %d:%d ok=%t", hour, minute, ok)
	}
}

// TestTaskFormLabelSuggestions verifies behavior for the covered scenario.
func TestTaskFormLabelSuggestions(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	t1, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Task 1",
		Priority:  domain.PriorityMedium,
		Labels:    []string{"planning", "kan"},
	}, now)
	t2, _ := domain.NewTask(domain.TaskInput{
		ID:        "t2",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  1,
		Title:     "Task 2",
		Priority:  domain.PriorityMedium,
		Labels:    []string{"kan", "roadmap"},
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{t1, t2})
	m := loadReadyModel(t, NewModel(svc))
	m = applyMsg(t, m, keyRune('n'))
	m = applyCmd(t, m, m.focusTaskFormField(4))
	accent := lipgloss.Color("62")
	muted := lipgloss.Color("241")
	dim := lipgloss.Color("239")
	helpStyle := lipgloss.NewStyle().Foreground(muted)
	out := m.renderModeOverlay(accent, muted, dim, helpStyle, 96)
	if !strings.Contains(out, "suggested labels:") {
		t.Fatalf("expected suggested labels hint, got %q", out)
	}
	if !strings.Contains(out, "kan") {
		t.Fatalf("expected label suggestions to include 'kan', got %q", out)
	}
}

// TestTaskFormCtrlYAcceptsLabelSuggestion verifies ctrl+y applies label autocomplete.
func TestTaskFormCtrlYAcceptsLabelSuggestion(t *testing.T) {
	now := time.Date(2026, 2, 22, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Task",
		Priority:  domain.PriorityMedium,
		Labels:    []string{"chore"},
	}, now)
	m := loadReadyModel(t, NewModel(newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task})))
	m = applyMsg(t, m, keyRune('n'))
	m = applyCmd(t, m, m.focusTaskFormField(4))
	m = applyMsg(t, m, keyRune('c'))
	m = applyMsg(t, m, keyRune('h'))
	m = applyMsg(t, m, tea.KeyPressMsg{Code: 'y', Mod: tea.ModCtrl})
	if got := strings.TrimSpace(m.formInputs[4].Value()); got != "chore" {
		t.Fatalf("expected ctrl+y to apply label suggestion, got %q", got)
	}
}

// TestProjectFormSavesRootPathOnCreate verifies project-form root path callback wiring.
func TestProjectFormSavesRootPathOnCreate(t *testing.T) {
	now := time.Date(2026, 2, 22, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	rootPath := t.TempDir()

	var savedSlug string
	var savedPath string
	m := loadReadyModel(t, NewModel(
		newFakeService([]domain.Project{p}, []domain.Column{c}, nil),
		WithSaveProjectRootCallback(func(projectSlug, root string) error {
			savedSlug = projectSlug
			savedPath = root
			return nil
		}),
	))
	m = applyMsg(t, m, keyRune('N'))
	if m.mode != modeAddProject {
		t.Fatalf("expected add-project mode, got %v", m.mode)
	}
	m.projectFormInputs[0].SetValue("Roadmap")
	m.projectFormInputs[7].SetValue(rootPath)
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if savedSlug == "" {
		t.Fatal("expected project-root callback to capture project slug")
	}
	if savedPath != rootPath {
		t.Fatalf("expected saved root path %q, got %q", rootPath, savedPath)
	}
}

// TestSearchAndCommandPaletteFlow verifies behavior for the covered scenario.
func TestSearchAndCommandPaletteFlow(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Roadmap planning",
		Priority:  domain.PriorityMedium,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task})
	m := loadReadyModel(t, NewModel(svc))

	m = applyMsg(t, m, keyRune('/'))
	for _, r := range []rune("road map") {
		m = applyMsg(t, m, keyRune(r))
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyTab}) // states
	m = applyMsg(t, m, keyRune(' '))                      // toggle todo off
	if m.isSearchStateEnabled("todo") {
		t.Fatalf("expected todo filter disabled, got %#v", m.searchStates)
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyTab}) // levels
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyTab}) // scope
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyTab}) // archived
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyTab}) // apply
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if !m.searchApplied {
		t.Fatalf("expected search applied, got %#v", m)
	}
	if m.searchQuery != "road map" {
		t.Fatalf("expected search query preserved, got %q", m.searchQuery)
	}
	if !m.searchCrossProject || !m.showArchived {
		t.Fatalf("expected scope+archived toggled, got cross=%t archived=%t", m.searchCrossProject, m.showArchived)
	}

	m = applyMsg(t, m, keyRune(':'))
	for _, r := range []rune("clear-q") {
		m = applyMsg(t, m, keyRune(r))
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyTab})
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if m.searchQuery != "" {
		t.Fatalf("expected clear-query command to clear text, got %q", m.searchQuery)
	}

	m = applyMsg(t, m, keyRune(':'))
	for _, r := range []rune("reset-f") {
		m = applyMsg(t, m, keyRune(r))
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if m.searchApplied {
		t.Fatalf("expected reset-filters to clear applied state, got %#v", m)
	}
}

// TestDueHelpers verifies behavior for the covered scenario.
func TestDueHelpers(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	past := now.Add(-2 * time.Hour)
	soon := now.Add(30 * time.Minute)
	later := now.Add(72 * time.Hour)
	archivedAt := now.Add(-10 * time.Minute)

	m := Model{
		dueSoonWindows: []time.Duration{time.Hour},
		tasks: []domain.Task{
			{ID: "t1", DueAt: &past},
			{ID: "t2", DueAt: &soon},
			{ID: "t3", DueAt: &later},
			{ID: "t4", DueAt: &soon, ArchivedAt: &archivedAt},
		},
	}
	overdue, dueSoon := m.dueCounts(now)
	if overdue != 1 || dueSoon != 1 {
		t.Fatalf("expected overdue=1 dueSoon=1, got %d/%d", overdue, dueSoon)
	}

	if got := dueWarning("2020-01-01", now); !strings.Contains(got, "in the past") {
		t.Fatalf("expected due warning for past datetime, got %q", got)
	}
	if got := dueWarning("2099-01-01", now); got != "" {
		t.Fatalf("expected no warning for future datetime, got %q", got)
	}

	if got := formatDueValue(&soon); !strings.Contains(got, soon.In(time.Local).Format("15:04")) {
		t.Fatalf("expected due value with time, got %q", got)
	}
	dateOnly := time.Date(2026, 2, 22, 0, 0, 0, 0, time.Local)
	if got := formatDueValue(&dateOnly); got != dateOnly.Format("2006-01-02") {
		t.Fatalf("expected date-only due format, got %q", got)
	}
}

// TestModelMouseSelectionModeDisablesMouseCapture verifies selection mode disables TUI mouse handling.
func TestModelMouseSelectionModeDisablesMouseCapture(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	t1, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "One",
		Priority:  domain.PriorityMedium,
	}, now)
	t2, _ := domain.NewTask(domain.TaskInput{
		ID:        "t2",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  1,
		Title:     "Two",
		Priority:  domain.PriorityMedium,
	}, now)
	m := loadReadyModel(t, NewModel(newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{t1, t2})))
	m.mouseSelectionMode = true

	before := m.selectedTask
	m = applyMsg(t, m, tea.MouseWheelMsg{Button: tea.MouseWheelDown})
	if m.selectedTask != before {
		t.Fatalf("expected mouse wheel ignored in selection mode, selected=%d before=%d", m.selectedTask, before)
	}
	view := m.View()
	if view.MouseMode != tea.MouseModeNone {
		t.Fatalf("expected mouse mode none in selection mode, got %v", view.MouseMode)
	}

	m.mouseSelectionMode = false
	view = m.View()
	if view.MouseMode != tea.MouseModeCellMotion {
		t.Fatalf("expected cell-motion mouse mode when selection mode disabled, got %v", view.MouseMode)
	}
}

// TestModelMultiSelectBulkMoveUndoRedo verifies behavior for the covered scenario.
func TestModelMultiSelectBulkMoveUndoRedo(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c1, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	c2, _ := domain.NewColumn("c2", p.ID, "Doing", 1, 0, now)
	t1, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c1.ID,
		Position:  0,
		Title:     "One",
		Priority:  domain.PriorityMedium,
	}, now)
	t2, _ := domain.NewTask(domain.TaskInput{
		ID:        "t2",
		ProjectID: p.ID,
		ColumnID:  c1.ID,
		Position:  1,
		Title:     "Two",
		Priority:  domain.PriorityLow,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c1, c2}, []domain.Task{t1, t2})
	m := loadReadyModel(t, NewModel(svc))

	m = applyMsg(t, m, keyRune(' '))
	m = applyMsg(t, m, keyRune('j'))
	m = applyMsg(t, m, keyRune(' '))
	if len(m.selectedTaskIDs) != 2 {
		t.Fatalf("expected 2 selected task ids, got %d", len(m.selectedTaskIDs))
	}

	updated, cmd := m.executeCommandPalette("bulk-move-right")
	m = applyResult(t, updated, cmd)
	if task, ok := svc.taskByID("t1"); !ok || task.ColumnID != c2.ID {
		t.Fatalf("expected t1 moved to %s, got %#v ok=%t", c2.ID, task, ok)
	}
	if task, ok := svc.taskByID("t2"); !ok || task.ColumnID != c2.ID {
		t.Fatalf("expected t2 moved to %s, got %#v ok=%t", c2.ID, task, ok)
	}

	m = applyMsg(t, m, keyRune('z'))
	if task, ok := svc.taskByID("t1"); !ok || task.ColumnID != c1.ID {
		t.Fatalf("expected t1 moved back to %s after undo, got %#v ok=%t", c1.ID, task, ok)
	}
	if task, ok := svc.taskByID("t2"); !ok || task.ColumnID != c1.ID {
		t.Fatalf("expected t2 moved back to %s after undo, got %#v ok=%t", c1.ID, task, ok)
	}
	if !strings.Contains(strings.ToLower(m.status), "undo") {
		t.Fatalf("expected undo status message, got %q", m.status)
	}

	m = applyMsg(t, m, keyRune('Z'))
	if task, ok := svc.taskByID("t1"); !ok || task.ColumnID != c2.ID {
		t.Fatalf("expected t1 moved again to %s after redo, got %#v ok=%t", c2.ID, task, ok)
	}
	if task, ok := svc.taskByID("t2"); !ok || task.ColumnID != c2.ID {
		t.Fatalf("expected t2 moved again to %s after redo, got %#v ok=%t", c2.ID, task, ok)
	}
	if !strings.Contains(strings.ToLower(m.status), "redo") {
		t.Fatalf("expected redo status message, got %q", m.status)
	}
}

// TestModelActivityLogOverlay verifies behavior for the covered scenario.
func TestModelActivityLogOverlay(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Task",
		Priority:  domain.PriorityMedium,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task})
	svc.changeEvents[p.ID] = []domain.ChangeEvent{
		{
			ID:         2,
			ProjectID:  p.ID,
			WorkItemID: task.ID,
			Operation:  domain.ChangeOperationMove,
			Metadata:   map[string]string{},
			OccurredAt: now.Add(2 * time.Minute),
		},
		{
			ID:         1,
			ProjectID:  p.ID,
			WorkItemID: task.ID,
			Operation:  domain.ChangeOperationCreate,
			Metadata:   map[string]string{"title": task.Title},
			OccurredAt: now.Add(time.Minute),
		},
	}
	m := loadReadyModel(t, NewModel(svc))

	m = applyMsg(t, m, keyRune('g'))
	if m.mode != modeActivityLog {
		t.Fatalf("expected activity-log mode, got %v", m.mode)
	}
	out := m.renderModeOverlay(lipgloss.Color("62"), lipgloss.Color("241"), lipgloss.Color("239"), lipgloss.NewStyle(), 96)
	if !strings.Contains(out, "Activity Log") {
		t.Fatalf("expected activity-log title, got %q", out)
	}
	if !strings.Contains(out, "move task") || !strings.Contains(out, "create task") {
		t.Fatalf("expected persisted activity entries, got %q", out)
	}
	if !strings.Contains(out, ":") {
		t.Fatalf("expected timestamp in activity entry, got %q", out)
	}
}

// TestModelActivityLogOverlayLoadFailure verifies graceful degradation when persisted activity fetch fails.
func TestModelActivityLogOverlayLoadFailure(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Task",
		Priority:  domain.PriorityMedium,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task})
	svc.changeEventsErr = errors.New("load failed")
	m := loadReadyModel(t, NewModel(svc))

	// Create one in-memory entry so the modal still has content after fetch failure.
	m = applyMsg(t, m, keyRune(' '))
	m = applyMsg(t, m, keyRune('g'))
	if m.mode != modeActivityLog {
		t.Fatalf("expected activity-log mode after load failure, got %v", m.mode)
	}
	if !strings.Contains(m.status, "activity log unavailable") {
		t.Fatalf("expected non-fatal activity load status, got %q", m.status)
	}
	out := m.renderModeOverlay(lipgloss.Color("62"), lipgloss.Color("241"), lipgloss.Color("239"), lipgloss.NewStyle(), 96)
	if !strings.Contains(out, "select task") {
		t.Fatalf("expected in-memory fallback entry after activity load failure, got %q", out)
	}
}

// TestModelGroupingByPriority verifies behavior for the covered scenario.
func TestModelGroupingByPriority(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 1, now)
	tLow, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Low first by position",
		Priority:  domain.PriorityLow,
	}, now)
	tHigh, _ := domain.NewTask(domain.TaskInput{
		ID:        "t2",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  1,
		Title:     "High later by position",
		Priority:  domain.PriorityHigh,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{tLow, tHigh})
	m := loadReadyModel(t, NewModel(svc, WithBoardConfig(BoardConfig{
		ShowWIPWarnings: true,
		GroupBy:         "priority",
	})))
	colTasks := m.tasksForColumn(c.ID)
	if len(colTasks) != 2 {
		t.Fatalf("expected 2 tasks, got %d", len(colTasks))
	}
	if colTasks[0].Priority != domain.PriorityHigh {
		t.Fatalf("expected high-priority task first under priority grouping, got %#v", colTasks)
	}
	if got := m.groupLabelForTask(colTasks[0]); got != "Priority: High" {
		t.Fatalf("unexpected group label %q", got)
	}
}

// TestWithKeyConfigOverrides verifies behavior for the covered scenario.
func TestWithKeyConfigOverrides(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Task",
		Priority:  domain.PriorityLow,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task})
	m := loadReadyModel(t, NewModel(svc, WithKeyConfig(KeyConfig{
		CommandPalette: ";",
		QuickActions:   ",",
		MultiSelect:    "x",
		ActivityLog:    "v",
		Undo:           "u",
		Redo:           "U",
	})))

	m = applyMsg(t, m, keyRune('x'))
	if len(m.selectedTaskIDs) != 1 {
		t.Fatalf("expected selection via configured key, got %d", len(m.selectedTaskIDs))
	}
	m = applyMsg(t, m, keyRune('v'))
	if m.mode != modeActivityLog {
		t.Fatalf("expected configured activity-log key to open modal, got %v", m.mode)
	}
}

// TestModelSelectionHelpers verifies selection helper behavior for the covered scenario.
func TestModelSelectionHelpers(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	c1, _ := domain.NewColumn("c1", "p1", "To Do", 0, 0, now)
	c2, _ := domain.NewColumn("c2", "p1", "Doing", 1, 0, now)
	t1, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: "p1",
		ColumnID:  c1.ID,
		Position:  0,
		Title:     "One",
		Priority:  domain.PriorityLow,
	}, now)
	t2, _ := domain.NewTask(domain.TaskInput{
		ID:        "t2",
		ProjectID: "p1",
		ColumnID:  c2.ID,
		Position:  0,
		Title:     "Two",
		Priority:  domain.PriorityMedium,
	}, now)
	m := Model{
		columns:         []domain.Column{c1, c2},
		tasks:           []domain.Task{t1, t2},
		selectedTaskIDs: map[string]struct{}{"t1": {}, "ghost": {}},
	}

	m.retainSelectionForLoadedTasks()
	if m.isTaskSelected("ghost") {
		t.Fatalf("expected stale selection removed, got %#v", m.selectedTaskIDs)
	}
	if !m.isTaskSelected("t1") {
		t.Fatalf("expected t1 still selected")
	}

	if selected := m.toggleTaskSelection("t1"); selected {
		t.Fatalf("expected toggle remove for existing selection")
	}
	if selected := m.toggleTaskSelection("t2"); !selected {
		t.Fatalf("expected toggle add for missing selection")
	}
	if got := m.sortedSelectedTaskIDs(); len(got) != 1 || got[0] != "t2" {
		t.Fatalf("expected deterministic selection order with t2 only, got %#v", got)
	}

	if removed := m.unselectTasks([]string{"t2", "missing"}); removed != 1 {
		t.Fatalf("expected removed=1, got %d", removed)
	}
	m.toggleTaskSelection("t1")
	m.toggleTaskSelection("t2")
	if cleared := m.clearSelection(); cleared != 2 {
		t.Fatalf("expected clearSelection to clear 2 entries, got %d", cleared)
	}
}

// TestModelHistoryGuards verifies undo/redo guard behavior for the covered scenario.
func TestModelHistoryGuards(t *testing.T) {
	m := Model{
		selectedTaskIDs: map[string]struct{}{},
	}

	updated, cmd := m.undoLastMutation()
	mOut, ok := updated.(Model)
	if !ok {
		t.Fatalf("expected Model from undo guard, got %T", updated)
	}
	if cmd != nil {
		t.Fatalf("expected nil cmd when undo stack empty")
	}
	if mOut.status != "nothing to undo" {
		t.Fatalf("expected empty-stack undo status, got %q", mOut.status)
	}

	mOut.undoStack = []historyActionSet{
		{
			Label:    "bulk hard delete",
			Undoable: false,
			Steps: []historyStep{
				{Kind: historyStepHardDelete, TaskID: "t1"},
			},
		},
	}
	updated, _ = mOut.undoLastMutation()
	mOut, ok = updated.(Model)
	if !ok {
		t.Fatalf("expected Model from non-undoable guard, got %T", updated)
	}
	if mOut.status != "last action cannot be undone" {
		t.Fatalf("expected non-undoable guard status, got %q", mOut.status)
	}
	if len(mOut.undoStack) != 0 {
		t.Fatalf("expected undo stack popped for non-undoable action, got %d", len(mOut.undoStack))
	}
	if len(mOut.activityLog) == 0 || !strings.Contains(mOut.activityLog[len(mOut.activityLog)-1].Summary, "undo") {
		t.Fatalf("expected activity log entry for undo-unavailable path, got %#v", mOut.activityLog)
	}

	mOut.redoStack = nil
	updated, cmd = mOut.redoLastMutation()
	mOut, ok = updated.(Model)
	if !ok {
		t.Fatalf("expected Model from redo guard, got %T", updated)
	}
	if cmd != nil {
		t.Fatalf("expected nil cmd when redo stack empty")
	}
	if mOut.status != "nothing to redo" {
		t.Fatalf("expected empty-stack redo status, got %q", mOut.status)
	}
}

// TestModelExecuteHistorySetHardDeleteUndo verifies hard-delete undo guard behavior.
func TestModelExecuteHistorySetHardDeleteUndo(t *testing.T) {
	m := Model{}
	msg := m.executeHistorySet(historyActionSet{
		Label: "hard delete selection",
		Steps: []historyStep{
			{Kind: historyStepHardDelete, TaskID: "t1"},
		},
	}, true)()
	action, ok := msg.(actionMsg)
	if !ok {
		t.Fatalf("expected actionMsg from executeHistorySet, got %T", msg)
	}
	if !strings.Contains(action.status, "hard delete cannot be restored") {
		t.Fatalf("expected hard-delete undo guard message, got %q", action.status)
	}
}

// TestModelMoveStepBuilderAndGroupingHelpers verifies helper behavior for ordering/grouping.
func TestModelMoveStepBuilderAndGroupingHelpers(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	c1, _ := domain.NewColumn("c1", "p1", "To Do", 0, 0, now)
	c2, _ := domain.NewColumn("c2", "p1", "Doing", 1, 0, now)
	t1, _ := domain.NewTask(domain.TaskInput{
		ID:             "t1",
		ProjectID:      "p1",
		ColumnID:       c1.ID,
		Position:       0,
		Title:          "One",
		Priority:       domain.PriorityHigh,
		LifecycleState: domain.StateTodo,
	}, now)
	t2, _ := domain.NewTask(domain.TaskInput{
		ID:             "t2",
		ProjectID:      "p1",
		ColumnID:       c1.ID,
		Position:       1,
		Title:          "Two",
		Priority:       domain.PriorityLow,
		LifecycleState: domain.StateDone,
	}, now)
	t3, _ := domain.NewTask(domain.TaskInput{
		ID:             "t3",
		ProjectID:      "p1",
		ColumnID:       c2.ID,
		Position:       0,
		Title:          "Three",
		Priority:       domain.PriorityMedium,
		LifecycleState: domain.StateProgress,
	}, now)
	m := Model{
		columns: []domain.Column{c1, c2},
		tasks:   []domain.Task{t1, t2, t3},
	}

	if got := m.buildMoveSteps([]string{"t1", "t2"}, 0); got != nil {
		t.Fatalf("expected nil move steps for delta=0, got %#v", got)
	}
	steps := m.buildMoveSteps([]string{"t2", "t1"}, 1)
	if len(steps) != 2 {
		t.Fatalf("expected 2 move steps, got %#v", steps)
	}
	if steps[0].TaskID != "t1" || steps[1].TaskID != "t2" {
		t.Fatalf("expected deterministic board ordering, got %#v", steps)
	}
	if steps[0].ToPosition != 1 || steps[1].ToPosition != 2 {
		t.Fatalf("expected target column append ordering, got %#v", steps)
	}

	if got := normalizeBoardGroupBy(" PRIORITY "); got != "priority" {
		t.Fatalf("unexpected normalizeBoardGroupBy priority result: %q", got)
	}
	if got := normalizeBoardGroupBy("state"); got != "state" {
		t.Fatalf("unexpected normalizeBoardGroupBy state result: %q", got)
	}
	if got := normalizeBoardGroupBy("weird"); got != "none" {
		t.Fatalf("unexpected normalizeBoardGroupBy fallback result: %q", got)
	}

	m.boardGroupBy = "priority"
	if got := m.groupLabelForTask(t1); got != "Priority: High" {
		t.Fatalf("unexpected priority group label: %q", got)
	}
	m.boardGroupBy = "state"
	if got := m.groupLabelForTask(t3); got != "State: In Progress" {
		t.Fatalf("unexpected state group label: %q", got)
	}
	if rank := taskGroupRank(t1, "priority"); rank != 0 {
		t.Fatalf("expected high priority rank=0, got %d", rank)
	}
	if rank := taskGroupRank(t2, "state"); rank != 2 {
		t.Fatalf("expected done state rank=2, got %d", rank)
	}
}

// TestModelActivityAndHistoryBounds verifies capped retention and transition helpers.
func TestModelActivityAndHistoryBounds(t *testing.T) {
	m := Model{}
	for i := 0; i < 205; i++ {
		m.appendActivity(activityEntry{
			At:      time.Date(2026, 2, 21, 12, 0, i%60, 0, time.UTC),
			Summary: "event",
		})
	}
	if len(m.activityLog) != 200 {
		t.Fatalf("expected bounded activity log length=200, got %d", len(m.activityLog))
	}
	if m.activityLog[0].Target != "-" {
		t.Fatalf("expected default activity target fallback, got %#v", m.activityLog[0])
	}

	m.redoStack = []historyActionSet{{ID: 99}}
	for i := 0; i < 105; i++ {
		m.pushUndoHistory(historyActionSet{
			Label:    "step",
			Undoable: true,
			Steps:    []historyStep{{Kind: historyStepMove, TaskID: "t1"}},
		})
	}
	if len(m.undoStack) != 100 {
		t.Fatalf("expected bounded undo stack length=100, got %d", len(m.undoStack))
	}
	if len(m.redoStack) != 0 {
		t.Fatalf("expected redo stack cleared after new push, got %d", len(m.redoStack))
	}

	last := m.undoStack[len(m.undoStack)-1]
	m.applyUndoTransition(last)
	if len(m.redoStack) != 1 {
		t.Fatalf("expected redo stack append after applyUndoTransition, got %d", len(m.redoStack))
	}
	m.applyRedoTransition(last)
	if len(m.undoStack) == 0 {
		t.Fatalf("expected undo stack append after applyRedoTransition")
	}
}

// TestModelModeLabelPromptAndActivityTimestamp verifies mode helper rendering.
func TestModelModeLabelPromptAndActivityTimestamp(t *testing.T) {
	m := Model{mode: modeActivityLog}
	if got := m.modeLabel(); got != "activity" {
		t.Fatalf("unexpected mode label %q", got)
	}
	if got := m.modePrompt(); !strings.Contains(got, "activity log") {
		t.Fatalf("unexpected mode prompt %q", got)
	}
	if got := formatActivityTimestamp(time.Time{}); got != "--:--:--" {
		t.Fatalf("unexpected zero timestamp format %q", got)
	}
	old := time.Date(2024, 1, 10, 5, 4, 0, 0, time.Local)
	if got := formatActivityTimestamp(old); !strings.Contains(got, "01-10") {
		t.Fatalf("expected old-date timestamp to include month/day, got %q", got)
	}
	now := time.Now()
	if got := formatActivityTimestamp(now); !strings.Contains(got, ":") {
		t.Fatalf("expected time-of-day timestamp, got %q", got)
	}
}

// TestResourcePickerHelpers verifies filesystem picker helper behavior.
func TestResourcePickerHelpers(t *testing.T) {
	root := t.TempDir()
	projectDir := filepath.Join(root, "project")
	if err := os.MkdirAll(filepath.Join(projectDir, "docs"), 0o755); err != nil {
		t.Fatalf("mkdir docs: %v", err)
	}
	if err := os.WriteFile(filepath.Join(projectDir, "README.md"), []byte("ok"), 0o644); err != nil {
		t.Fatalf("write README: %v", err)
	}

	entries, current, err := listResourcePickerEntries(projectDir, projectDir)
	if err != nil {
		t.Fatalf("listResourcePickerEntries root: %v", err)
	}
	if current != projectDir {
		t.Fatalf("expected current dir %q, got %q", projectDir, current)
	}
	if len(entries) < 2 {
		t.Fatalf("expected at least docs+README entries, got %#v", entries)
	}
	if !entries[0].IsDir {
		t.Fatalf("expected directories sorted before files, got %#v", entries)
	}

	// Outside paths should be honored so callers can navigate to parent directories.
	_, current, err = listResourcePickerEntries(projectDir, root)
	if err != nil {
		t.Fatalf("listResourcePickerEntries outside root: %v", err)
	}
	if current != root {
		t.Fatalf("expected outside current dir %q, got %q", root, current)
	}
}

// TestResourceRefHelpers verifies reference normalization and duplicate suppression.
func TestResourceRefHelpers(t *testing.T) {
	root := t.TempDir()
	filePath := filepath.Join(root, "notes.txt")
	if err := os.WriteFile(filePath, []byte("ok"), 0o644); err != nil {
		t.Fatalf("write notes: %v", err)
	}

	ref := buildResourceRef(root, filePath, false)
	if ref.ResourceType != domain.ResourceTypeLocalFile {
		t.Fatalf("expected local_file resource, got %q", ref.ResourceType)
	}
	if ref.PathMode != domain.PathModeRelative {
		t.Fatalf("expected relative path mode under root, got %q", ref.PathMode)
	}
	if ref.BaseAlias != "project_root" {
		t.Fatalf("expected project_root base alias, got %q", ref.BaseAlias)
	}

	refs, added := appendResourceRefIfMissing(nil, ref)
	if !added || len(refs) != 1 {
		t.Fatalf("expected first ref append, got added=%t refs=%#v", added, refs)
	}
	refs, added = appendResourceRefIfMissing(refs, ref)
	if added || len(refs) != 1 {
		t.Fatalf("expected duplicate suppression, got added=%t refs=%#v", added, refs)
	}
}

// TestProjectionAndRollupHelpers verifies subtree projection and summary helper behavior.
func TestProjectionAndRollupHelpers(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	c1, _ := domain.NewColumn("c1", "p1", "To Do", 0, 0, now)
	c2, _ := domain.NewColumn("c2", "p1", "Doing", 1, 0, now)
	phase, _ := domain.NewTask(domain.TaskInput{
		ID:        "phase",
		ProjectID: "p1",
		ColumnID:  c1.ID,
		Position:  0,
		Kind:      domain.WorkKindPhase,
		Title:     "Phase",
		Priority:  domain.PriorityMedium,
	}, now)
	child, _ := domain.NewTask(domain.TaskInput{
		ID:        "child",
		ProjectID: "p1",
		ParentID:  phase.ID,
		ColumnID:  c2.ID,
		Position:  0,
		Title:     "Child",
		Priority:  domain.PriorityLow,
	}, now)
	unrelated, _ := domain.NewTask(domain.TaskInput{
		ID:        "other",
		ProjectID: "p1",
		ColumnID:  c1.ID,
		Position:  1,
		Title:     "Other",
		Priority:  domain.PriorityHigh,
	}, now)

	m := Model{
		columns: []domain.Column{c1, c2},
		tasks:   []domain.Task{phase, child, unrelated},
		dependencyRollup: domain.DependencyRollup{
			TotalItems:                3,
			BlockedItems:              1,
			UnresolvedDependencyEdges: 2,
			DependencyEdges:           4,
		},
	}
	m.projectionRootTaskID = phase.ID
	set := m.projectedTaskSet()
	if len(set) != 1 {
		t.Fatalf("expected projected set with direct children only, got %#v", set)
	}
	if _, ok := set[child.ID]; !ok {
		t.Fatalf("expected child task in projected set, got %#v", set)
	}
	if _, ok := set[unrelated.ID]; ok {
		t.Fatalf("did not expect unrelated task in projected set")
	}

	col1 := m.tasksForColumn(c1.ID)
	if len(col1) != 0 {
		t.Fatalf("expected focused scope column without direct children to be empty, got %#v", col1)
	}
	if breadcrumb := m.projectionBreadcrumb(); breadcrumb != "Phase" {
		t.Fatalf("unexpected projection breadcrumb %q", breadcrumb)
	}
	if summary := m.dependencyRollupSummary(); !strings.Contains(summary, "blocked 1") {
		t.Fatalf("unexpected dependency summary %q", summary)
	}
}

// TestProjectRootLookup verifies strict project-root lookup and non-task browse fallback behavior.
func TestProjectRootLookup(t *testing.T) {
	root := t.TempDir()
	p := domain.Project{ID: "p1", Slug: "inbox", Name: "Inbox"}
	m := Model{
		projects:     []domain.Project{p},
		projectRoots: map[string]string{"inbox": root},
	}
	if got := m.resourcePickerRootForCurrentProject(); got != root {
		t.Fatalf("expected configured project root %q, got %q", root, got)
	}

	m.projectRoots = map[string]string{}
	m.defaultRootDir = "."
	if got := m.resourcePickerRootForCurrentProject(); got != "" {
		t.Fatalf("expected empty project-root lookup when mapping is unset, got %q", got)
	}
	if got := m.resourcePickerBrowseRoot(); got == "" {
		t.Fatal("expected non-empty browse root fallback")
	}
}

// TestLabelInheritanceHelpers verifies label inheritance and picker helper behavior.
func TestLabelInheritanceHelpers(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p := domain.Project{ID: "p1", Slug: "inbox", Name: "Inbox"}
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	phase, _ := domain.NewTask(domain.TaskInput{
		ID:        "phase",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Kind:      domain.WorkKindPhase,
		Position:  0,
		Title:     "Phase",
		Labels:    []string{"PhaseA", "shared"},
		Priority:  domain.PriorityMedium,
	}, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "task",
		ProjectID: p.ID,
		ParentID:  phase.ID,
		ColumnID:  c.ID,
		Position:  1,
		Title:     "Task",
		Labels:    []string{"task-only"},
		Priority:  domain.PriorityLow,
	}, now)
	m := Model{
		projects:            []domain.Project{p},
		columns:             []domain.Column{c},
		tasks:               []domain.Task{phase, task},
		selectedColumn:      0,
		selectedTask:        1,
		allowedLabelGlobal:  []string{"global", "shared"},
		allowedLabelProject: map[string][]string{"inbox": {"project", "shared"}},
	}

	phaseLabels := m.labelsFromPhaseAncestors(task)
	if len(phaseLabels) != 2 || phaseLabels[0] != "phasea" {
		t.Fatalf("unexpected phase ancestor labels %#v", phaseLabels)
	}

	merged := mergeLabelSources(labelInheritanceSources{
		Global:  []string{"Global", "shared"},
		Project: []string{"Project", "shared"},
		Phase:   []string{"PhaseA", "project"},
	})
	if len(merged) != 4 || merged[0] != "global" {
		t.Fatalf("unexpected merged label set %#v", merged)
	}

	m.taskFormParentID = phase.ID
	_ = m.startTaskForm(nil)
	m.taskFormParentID = phase.ID
	items := m.taskFormLabelPickerItems()
	if len(items) == 0 {
		t.Fatalf("expected label picker items from inheritance sources")
	}

	m.formInputs[4].SetValue("alpha")
	m.appendTaskFormLabel("beta")
	m.appendTaskFormLabel("alpha")
	if got := m.formInputs[4].Value(); got != "alpha,beta" {
		t.Fatalf("expected de-duplicated label append, got %q", got)
	}
}

// TestResourcePickerEntrySelectionAndParent verifies picker-selection helper behavior.
func TestResourcePickerEntrySelectionAndParent(t *testing.T) {
	root := t.TempDir()
	if err := os.MkdirAll(filepath.Join(root, "child"), 0o755); err != nil {
		t.Fatalf("mkdir child: %v", err)
	}
	m := Model{
		resourcePickerRoot:  root,
		resourcePickerDir:   filepath.Join(root, "child"),
		resourcePickerItems: []resourcePickerEntry{{Name: "child", Path: filepath.Join(root, "child"), IsDir: true}},
		resourcePickerIndex: 0,
	}
	entry, ok := m.selectedResourcePickerEntry()
	if !ok || entry.Name != "child" {
		t.Fatalf("expected selected picker entry child, got %#v ok=%t", entry, ok)
	}

	msg := m.openResourcePickerParent()()
	loaded, ok := msg.(resourcePickerLoadedMsg)
	if !ok {
		t.Fatalf("expected resourcePickerLoadedMsg, got %T", msg)
	}
	if loaded.err != nil {
		t.Fatalf("expected parent directory load success, got %v", loaded.err)
	}
	if loaded.current != root {
		t.Fatalf("expected parent load to clamp at root %q, got %q", root, loaded.current)
	}

	m.resourcePickerDir = root
	msg = m.openResourcePickerParent()()
	loaded, ok = msg.(resourcePickerLoadedMsg)
	if !ok {
		t.Fatalf("expected resourcePickerLoadedMsg from root-parent nav, got %T", msg)
	}
	if loaded.err != nil {
		t.Fatalf("expected root-parent directory load success, got %v", loaded.err)
	}
	if loaded.current != filepath.Dir(root) {
		t.Fatalf("expected root parent %q, got %q", filepath.Dir(root), loaded.current)
	}
}

// TestModelResourcePickerAttachFromTaskInfoAndEdit verifies resource attachment flows.
func TestModelResourcePickerAttachFromTaskInfoAndEdit(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Task",
		Priority:  domain.PriorityMedium,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task})

	root := t.TempDir()
	if err := os.Mkdir(filepath.Join(root, "docs"), 0o755); err != nil {
		t.Fatalf("Mkdir() error = %v", err)
	}
	if err := os.WriteFile(filepath.Join(root, "notes.md"), []byte("spec"), 0o644); err != nil {
		t.Fatalf("WriteFile() error = %v", err)
	}

	m := loadReadyModel(t, NewModel(svc, WithProjectRoots(map[string]string{"inbox": root})))
	m = applyMsg(t, m, keyRune('i'))
	m = applyMsg(t, m, keyRune('r'))
	if m.mode != modeResourcePicker {
		t.Fatalf("expected resource picker mode from task info, got %v", m.mode)
	}
	if got := strings.TrimSpace(m.resourcePickerRoot); got != root {
		t.Fatalf("expected resource root %q, got %q", root, got)
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyDown}) // first file after directory entry
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if m.mode != modeTaskInfo {
		t.Fatalf("expected return to task info mode after attach, got %v", m.mode)
	}

	updated, ok := svc.taskByID("t1")
	if !ok {
		t.Fatal("expected updated task in fake service")
	}
	if len(updated.Metadata.ResourceRefs) != 1 {
		t.Fatalf("expected 1 attached resource, got %#v", updated.Metadata.ResourceRefs)
	}
	ref := updated.Metadata.ResourceRefs[0]
	if ref.ResourceType != domain.ResourceTypeLocalFile {
		t.Fatalf("expected local file resource type, got %q", ref.ResourceType)
	}
	if ref.PathMode != domain.PathModeRelative || ref.BaseAlias != "project_root" {
		t.Fatalf("expected project-root relative reference, got %#v", ref)
	}
	if filepath.ToSlash(ref.Location) != "notes.md" {
		t.Fatalf("expected relative location notes.md, got %q", ref.Location)
	}

	m.mode = modeNone
	m = applyMsg(t, m, keyRune('e'))
	m = applyMsg(t, m, tea.KeyPressMsg{Code: 'r', Mod: tea.ModCtrl})
	if m.mode != modeResourcePicker {
		t.Fatalf("expected resource picker mode from edit-task ctrl+r, got %v", m.mode)
	}
}

// TestModelResourcePickerBlockedWithoutProjectRoot verifies task attachment flows fail closed when project root mapping is missing.
func TestModelResourcePickerBlockedWithoutProjectRoot(t *testing.T) {
	now := time.Date(2026, 2, 24, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Task",
		Priority:  domain.PriorityMedium,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task})
	m := loadReadyModel(t, NewModel(
		svc,
		WithSearchRoots([]string{t.TempDir()}),
	))

	m = applyMsg(t, m, keyRune('i'))
	if m.mode != modeTaskInfo {
		t.Fatalf("expected task info mode, got %v", m.mode)
	}
	m = applyMsg(t, m, keyRune('r'))
	if m.mode != modeTaskInfo {
		t.Fatalf("expected task info mode after blocked attach, got %v", m.mode)
	}
	if !strings.Contains(m.status, "set project root first") {
		t.Fatalf("expected blocked-attach status in task info mode, got %q", m.status)
	}

	m.mode = modeNone
	m = applyMsg(t, m, keyRune('e'))
	if m.mode != modeEditTask {
		t.Fatalf("expected edit mode, got %v", m.mode)
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: 'r', Mod: tea.ModCtrl})
	if m.mode != modeEditTask {
		t.Fatalf("expected edit mode after blocked ctrl+r attach, got %v", m.mode)
	}
	if !strings.Contains(m.status, "set project root first") {
		t.Fatalf("expected blocked-attach status in edit mode, got %q", m.status)
	}
}

// TestModelLabelInheritanceSourcesAndPicker verifies inherited label UX in task info/form flows.
func TestModelLabelInheritanceSourcesAndPicker(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	phase, _ := domain.NewTask(domain.TaskInput{
		ID:        "phase-1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Kind:      domain.WorkKindPhase,
		Title:     "Phase",
		Priority:  domain.PriorityMedium,
		Labels:    []string{"phase-label"},
	}, now)
	child, _ := domain.NewTask(domain.TaskInput{
		ID:        "task-1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  1,
		ParentID:  phase.ID,
		Kind:      domain.WorkKindTask,
		Title:     "Child Task",
		Priority:  domain.PriorityMedium,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{phase, child})
	m := loadReadyModel(t, NewModel(svc, WithLabelConfig(LabelConfig{
		Global:   []string{"global-label"},
		Projects: map[string][]string{"inbox": []string{"project-label"}},
	})))

	m = applyMsg(t, m, keyRune('j')) // select child task
	m = applyMsg(t, m, keyRune('i'))
	info := m.renderModeOverlay(lipgloss.Color("62"), lipgloss.Color("241"), lipgloss.Color("239"), lipgloss.NewStyle(), 96)
	if !strings.Contains(info, "effective labels") {
		t.Fatalf("expected effective labels section, got %q", info)
	}
	if !strings.Contains(info, "global: global-label") || !strings.Contains(info, "project: project-label") || !strings.Contains(info, "phase: phase-label") {
		t.Fatalf("expected inherited label sources in task info, got %q", info)
	}

	m = applyMsg(t, m, keyRune('e'))
	for i := 0; i < 4; i++ {
		m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyTab})
	}
	if m.formFocus != 4 {
		t.Fatalf("expected labels form focus, got %d", m.formFocus)
	}
	editOverlay := m.renderModeOverlay(lipgloss.Color("62"), lipgloss.Color("241"), lipgloss.Color("239"), lipgloss.NewStyle(), 96)
	if !strings.Contains(editOverlay, "inherited labels") {
		t.Fatalf("expected inherited label hint in task form, got %q", editOverlay)
	}

	m = applyMsg(t, m, tea.KeyPressMsg{Code: 'l', Mod: tea.ModCtrl})
	if m.mode != modeLabelPicker {
		t.Fatalf("expected label picker mode, got %v", m.mode)
	}
	m = applyMsg(t, m, keyRune('j'))
	m = applyMsg(t, m, keyRune('j'))
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if m.mode != modeEditTask {
		t.Fatalf("expected return to edit-task after picker choose, got %v", m.mode)
	}
	if got := m.formInputs[4].Value(); !strings.Contains(got, "phase-label") {
		t.Fatalf("expected appended phase label in form value, got %q", got)
	}
}

// TestModelProjectionFocusBreadcrumbMode verifies subtree focus mode and breadcrumb switching.
func TestModelProjectionFocusBreadcrumbMode(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	parent, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-parent",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Parent",
		Priority:  domain.PriorityMedium,
	}, now)
	child, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-child",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  1,
		ParentID:  parent.ID,
		Title:     "Child",
		Priority:  domain.PriorityMedium,
	}, now)
	grandchild, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-grandchild",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  2,
		ParentID:  child.ID,
		Title:     "Grandchild",
		Priority:  domain.PriorityLow,
	}, now)
	other, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-other",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  3,
		Title:     "Unrelated",
		Priority:  domain.PriorityLow,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{parent, child, grandchild, other})
	m := loadReadyModel(t, NewModel(svc))

	m.focusTaskByID(parent.ID)
	m = applyMsg(t, m, keyRune('f')) // enter parent scope (child becomes selected)
	m = applyMsg(t, m, keyRune('f')) // enter child scope
	if m.projectionRootTaskID != child.ID {
		t.Fatalf("expected projection root %q, got %q", child.ID, m.projectionRootTaskID)
	}
	tasks := m.currentColumnTasks()
	if len(tasks) != 1 || tasks[0].ID != grandchild.ID {
		t.Fatalf("expected projected child scope to show direct children only, got %#v", tasks)
	}
	if got := m.projectionBreadcrumb(); got != "Parent / Child" {
		t.Fatalf("expected breadcrumb Parent / Child, got %q", got)
	}
	focusedView := stripANSI(fmt.Sprint(m.View().Content))
	if !strings.Contains(focusedView, "path: Inbox -> Parent -> Child") {
		t.Fatalf("expected explicit focus path line in view, got\n%s", focusedView)
	}
	if m.modePrompt() != "" {
		t.Fatalf("expected normal-mode prompt while projected, got %q", m.modePrompt())
	}

	m = applyMsg(t, m, keyRune('F'))
	if m.projectionRootTaskID != "" {
		t.Fatalf("expected focus cleared after F, got %q", m.projectionRootTaskID)
	}
	if len(m.currentColumnTasks()) != 2 {
		t.Fatalf("expected full board tasks after clearing focus, got %d", len(m.currentColumnTasks()))
	}
	fullBoardView := stripANSI(fmt.Sprint(m.View().Content))
	if !strings.Contains(fullBoardView, "path: Inbox") {
		t.Fatalf("expected project path while not focused, got\n%s", fullBoardView)
	}
}

// TestModelFocusSubtreeRendersBoardForHierarchyLevels verifies branch/phase/subphase focus keeps project-board columns visible.
func TestModelFocusSubtreeRendersBoardForHierarchyLevels(t *testing.T) {
	now := time.Date(2026, 2, 24, 9, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Roadmap", "", now)
	todo, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	progress, _ := domain.NewColumn("c2", p.ID, "In Progress", 1, 0, now)
	done, _ := domain.NewColumn("c3", p.ID, "Done", 2, 0, now)

	branch, _ := domain.NewTask(domain.TaskInput{
		ID:        "w-branch",
		ProjectID: p.ID,
		ColumnID:  todo.ID,
		Position:  0,
		Title:     "Branch",
		Priority:  domain.PriorityMedium,
		Kind:      domain.WorkKind("branch"),
		Scope:     domain.KindAppliesToBranch,
	}, now)
	phase, _ := domain.NewTask(domain.TaskInput{
		ID:        "w-phase",
		ProjectID: p.ID,
		ParentID:  branch.ID,
		ColumnID:  progress.ID,
		Position:  0,
		Title:     "Phase",
		Priority:  domain.PriorityMedium,
		Kind:      domain.WorkKindPhase,
		Scope:     domain.KindAppliesToPhase,
	}, now)
	subphase, _ := domain.NewTask(domain.TaskInput{
		ID:        "w-subphase",
		ProjectID: p.ID,
		ParentID:  phase.ID,
		ColumnID:  done.ID,
		Position:  0,
		Title:     "Subphase",
		Priority:  domain.PriorityMedium,
		Kind:      domain.WorkKindPhase,
		Scope:     domain.KindAppliesToPhase,
	}, now)
	leafTask, _ := domain.NewTask(domain.TaskInput{
		ID:        "w-task",
		ProjectID: p.ID,
		ParentID:  subphase.ID,
		ColumnID:  done.ID,
		Position:  1,
		Title:     "Task",
		Priority:  domain.PriorityLow,
		Kind:      domain.WorkKindTask,
		Scope:     domain.KindAppliesToTask,
	}, now)
	unrelated, _ := domain.NewTask(domain.TaskInput{
		ID:        "w-other",
		ProjectID: p.ID,
		ColumnID:  todo.ID,
		Position:  1,
		Title:     "Other",
		Priority:  domain.PriorityLow,
		Kind:      domain.WorkKindTask,
		Scope:     domain.KindAppliesToTask,
	}, now)

	svc := newFakeService(
		[]domain.Project{p},
		[]domain.Column{todo, progress, done},
		[]domain.Task{branch, phase, subphase, leafTask, unrelated},
	)
	m := loadReadyModel(t, NewModel(svc))
	visibleIDs := func(in Model) []string {
		out := make([]string, 0)
		for _, column := range in.columns {
			for _, task := range in.boardTasksForColumn(column.ID) {
				out = append(out, task.ID)
			}
		}
		return out
	}
	assertVisible := func(in Model, expected []string) {
		t.Helper()
		got := strings.Join(visibleIDs(in), ",")
		want := strings.Join(expected, ",")
		if got != want {
			t.Fatalf("unexpected focused board ids\nwant: %s\ngot:  %s", want, got)
		}
		rendered := stripANSI(fmt.Sprint(in.View().Content))
		if !strings.Contains(rendered, "To Do (") || !strings.Contains(rendered, "In Progress (") || !strings.Contains(rendered, "Done (") {
			t.Fatalf("expected project-board columns while focused, got\n%s", rendered)
		}
	}

	assertVisible(m, []string{branch.ID, unrelated.ID})

	m.focusTaskByID(branch.ID)
	m = applyMsg(t, m, keyRune('f'))
	assertVisible(m, []string{phase.ID})

	m = applyMsg(t, m, keyRune('f'))
	assertVisible(m, []string{subphase.ID})

	m = applyMsg(t, m, keyRune('f'))
	assertVisible(m, []string{leafTask.ID})
}

// TestModelFocusTaskScopeShowsSubtasks verifies task-focused scope rendering includes direct subtasks.
func TestModelFocusTaskScopeShowsSubtasks(t *testing.T) {
	now := time.Date(2026, 2, 25, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	todo, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	done, _ := domain.NewColumn("c2", p.ID, "Done", 1, 0, now)
	parent, _ := domain.NewTask(domain.TaskInput{
		ID:        "task-root",
		ProjectID: p.ID,
		ColumnID:  todo.ID,
		Position:  0,
		Title:     "Parent Task",
		Priority:  domain.PriorityMedium,
		Kind:      domain.WorkKindTask,
		Scope:     domain.KindAppliesToTask,
	}, now)
	subA, _ := domain.NewTask(domain.TaskInput{
		ID:        "sub-a",
		ProjectID: p.ID,
		ParentID:  parent.ID,
		ColumnID:  todo.ID,
		Position:  1,
		Title:     "Subtask A",
		Priority:  domain.PriorityLow,
		Kind:      domain.WorkKindSubtask,
		Scope:     domain.KindAppliesToSubtask,
	}, now)
	subB, _ := domain.NewTask(domain.TaskInput{
		ID:        "sub-b",
		ProjectID: p.ID,
		ParentID:  parent.ID,
		ColumnID:  done.ID,
		Position:  0,
		Title:     "Subtask B",
		Priority:  domain.PriorityLow,
		Kind:      domain.WorkKindSubtask,
		Scope:     domain.KindAppliesToSubtask,
	}, now)
	other, _ := domain.NewTask(domain.TaskInput{
		ID:        "task-other",
		ProjectID: p.ID,
		ColumnID:  todo.ID,
		Position:  2,
		Title:     "Other Top Task",
		Priority:  domain.PriorityLow,
		Kind:      domain.WorkKindTask,
		Scope:     domain.KindAppliesToTask,
	}, now)

	m := loadReadyModel(t, NewModel(newFakeService(
		[]domain.Project{p},
		[]domain.Column{todo, done},
		[]domain.Task{parent, subA, subB, other},
	)))

	projectScope := stripANSI(fmt.Sprint(m.View().Content))
	if strings.Contains(projectScope, "Subtask A") || strings.Contains(projectScope, "Subtask B") {
		t.Fatalf("expected project scope board to hide subtasks, got\n%s", projectScope)
	}

	m.focusTaskByID(parent.ID)
	m = applyMsg(t, m, keyRune('f'))
	visible := []string{}
	for _, column := range m.columns {
		for _, task := range m.boardTasksForColumn(column.ID) {
			visible = append(visible, task.ID)
		}
	}
	got := strings.Join(visible, ",")
	if got != "sub-a,sub-b" {
		t.Fatalf("expected task-focused scope to show direct subtasks, got %s", got)
	}
	focused := stripANSI(fmt.Sprint(m.View().Content))
	if !strings.Contains(focused, "path: Inbox -> Parent Task") {
		t.Fatalf("expected focused task path in board view, got\n%s", focused)
	}
}

// TestModelNewTaskFormDefaultsFollowFocusedScope verifies add-task defaults follow active focus scope.
func TestModelNewTaskFormDefaultsFollowFocusedScope(t *testing.T) {
	now := time.Date(2026, 2, 25, 14, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Roadmap", "", now)
	todo, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	branch, _ := domain.NewTask(domain.TaskInput{
		ID:        "b1",
		ProjectID: p.ID,
		ColumnID:  todo.ID,
		Position:  0,
		Title:     "Branch",
		Priority:  domain.PriorityMedium,
		Kind:      domain.WorkKind("branch"),
		Scope:     domain.KindAppliesToBranch,
	}, now)
	phase, _ := domain.NewTask(domain.TaskInput{
		ID:        "ph1",
		ProjectID: p.ID,
		ParentID:  branch.ID,
		ColumnID:  todo.ID,
		Position:  1,
		Title:     "Phase",
		Priority:  domain.PriorityMedium,
		Kind:      domain.WorkKindPhase,
		Scope:     domain.KindAppliesToPhase,
	}, now)
	subphase, _ := domain.NewTask(domain.TaskInput{
		ID:        "sph1",
		ProjectID: p.ID,
		ParentID:  phase.ID,
		ColumnID:  todo.ID,
		Position:  2,
		Title:     "Subphase",
		Priority:  domain.PriorityMedium,
		Kind:      domain.WorkKindPhase,
		Scope:     domain.KindAppliesToSubphase,
	}, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "t1",
		ProjectID: p.ID,
		ParentID:  subphase.ID,
		ColumnID:  todo.ID,
		Position:  3,
		Title:     "Task",
		Priority:  domain.PriorityMedium,
		Kind:      domain.WorkKindTask,
		Scope:     domain.KindAppliesToTask,
	}, now)
	subtask, _ := domain.NewTask(domain.TaskInput{
		ID:        "st1",
		ProjectID: p.ID,
		ParentID:  task.ID,
		ColumnID:  todo.ID,
		Position:  4,
		Title:     "Subtask",
		Priority:  domain.PriorityLow,
		Kind:      domain.WorkKindSubtask,
		Scope:     domain.KindAppliesToSubtask,
	}, now)
	m := loadReadyModel(t, NewModel(newFakeService(
		[]domain.Project{p},
		[]domain.Column{todo},
		[]domain.Task{branch, phase, subphase, task, subtask},
	)))

	assertDefaults := func(parentID string, kind domain.WorkKind, scope domain.KindAppliesTo) {
		t.Helper()
		if got := m.taskFormParentID; got != parentID {
			t.Fatalf("task form parent = %q, want %q", got, parentID)
		}
		if got := m.taskFormKind; got != kind {
			t.Fatalf("task form kind = %q, want %q", got, kind)
		}
		if got := m.taskFormScope; got != scope {
			t.Fatalf("task form scope = %q, want %q", got, scope)
		}
	}

	m = applyMsg(t, m, keyRune('n'))
	assertDefaults("", domain.WorkKindTask, domain.KindAppliesToTask)
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEscape})

	m.focusTaskByID(branch.ID)
	m = applyMsg(t, m, keyRune('f'))
	m = applyMsg(t, m, keyRune('n'))
	assertDefaults(branch.ID, domain.WorkKindTask, domain.KindAppliesToTask)
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEscape})

	m = applyMsg(t, m, keyRune('f'))
	m = applyMsg(t, m, keyRune('n'))
	assertDefaults(phase.ID, domain.WorkKindTask, domain.KindAppliesToTask)
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEscape})

	m = applyMsg(t, m, keyRune('f'))
	m = applyMsg(t, m, keyRune('n'))
	assertDefaults(subphase.ID, domain.WorkKindTask, domain.KindAppliesToTask)
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEscape})

	m = applyMsg(t, m, keyRune('f'))
	m = applyMsg(t, m, keyRune('n'))
	assertDefaults(task.ID, domain.WorkKindSubtask, domain.KindAppliesToSubtask)
}

// TestModelCreateTaskFromFocusedScopeUsesScopedParent verifies submitted create-task calls carry focused defaults.
func TestModelCreateTaskFromFocusedScopeUsesScopedParent(t *testing.T) {
	now := time.Date(2026, 2, 25, 14, 30, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Roadmap", "", now)
	todo, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	branch, _ := domain.NewTask(domain.TaskInput{
		ID:        "b1",
		ProjectID: p.ID,
		ColumnID:  todo.ID,
		Position:  0,
		Title:     "Branch",
		Priority:  domain.PriorityMedium,
		Kind:      domain.WorkKind("branch"),
		Scope:     domain.KindAppliesToBranch,
	}, now)
	phase, _ := domain.NewTask(domain.TaskInput{
		ID:        "ph1",
		ProjectID: p.ID,
		ParentID:  branch.ID,
		ColumnID:  todo.ID,
		Position:  1,
		Title:     "Phase",
		Priority:  domain.PriorityMedium,
		Kind:      domain.WorkKindPhase,
		Scope:     domain.KindAppliesToPhase,
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{todo}, []domain.Task{branch, phase})
	m := loadReadyModel(t, NewModel(svc))
	m.focusTaskByID(branch.ID)
	m = applyMsg(t, m, keyRune('f'))
	m = applyMsg(t, m, keyRune('n'))
	if m.mode != modeAddTask {
		t.Fatalf("expected add-task mode, got %v", m.mode)
	}
	m.formInputs[taskFieldTitle].SetValue("Focused child")
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if svc.createTaskCalls != 1 {
		t.Fatalf("expected one create-task call, got %d", svc.createTaskCalls)
	}
	if got := svc.lastCreateTask.ParentID; got != branch.ID {
		t.Fatalf("create parent_id = %q, want %q", got, branch.ID)
	}
	if got := svc.lastCreateTask.Kind; got != domain.WorkKindTask {
		t.Fatalf("create kind = %q, want %q", got, domain.WorkKindTask)
	}
	if got := svc.lastCreateTask.Scope; got != domain.KindAppliesToTask {
		t.Fatalf("create scope = %q, want %q", got, domain.KindAppliesToTask)
	}
}

// TestModelViewShowsSubtreeDiscoverabilityHint verifies hierarchy focus guidance in the board info line.
func TestModelViewShowsSubtreeDiscoverabilityHint(t *testing.T) {
	now := time.Date(2026, 2, 24, 11, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Roadmap", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	branch, _ := domain.NewTask(domain.TaskInput{
		ID:        "b1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Branch",
		Priority:  domain.PriorityMedium,
		Kind:      domain.WorkKind("branch"),
		Scope:     domain.KindAppliesToBranch,
	}, now)
	phase, _ := domain.NewTask(domain.TaskInput{
		ID:        "p2",
		ProjectID: p.ID,
		ParentID:  branch.ID,
		ColumnID:  c.ID,
		Position:  1,
		Title:     "Phase",
		Priority:  domain.PriorityMedium,
		Kind:      domain.WorkKindPhase,
		Scope:     domain.KindAppliesToPhase,
	}, now)

	m := loadReadyModel(t, NewModel(newFakeService(
		[]domain.Project{p},
		[]domain.Column{c},
		[]domain.Task{branch, phase},
	)))
	view := stripANSI(fmt.Sprint(m.View().Content))
	if !strings.Contains(view, "level: branch") {
		t.Fatalf("expected selected hierarchy level in info line, got\n%s", view)
	}
	if !strings.Contains(view, "children: 1") {
		t.Fatalf("expected direct child count in info line, got\n%s", view)
	}
	if !strings.Contains(view, "f focus subtree") {
		t.Fatalf("expected focus subtree hint in info line, got\n%s", view)
	}

	m = applyMsg(t, m, keyRune('f'))
	focused := stripANSI(fmt.Sprint(m.View().Content))
	if !strings.Contains(focused, "F full board") {
		t.Fatalf("expected full-board hint while focused, got\n%s", focused)
	}
	if !strings.Contains(focused, "path: Roadmap -> Branch") {
		t.Fatalf("expected focused path line while subtree focus is active, got\n%s", focused)
	}
}

// TestModelFocusSubtreeNoChildrenNoOp verifies pressing f on leaf nodes does not enter empty focus mode.
func TestModelFocusSubtreeNoChildrenNoOp(t *testing.T) {
	now := time.Date(2026, 2, 25, 13, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Roadmap", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "leaf-task",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Leaf Task",
		Priority:  domain.PriorityMedium,
		Kind:      domain.WorkKindTask,
		Scope:     domain.KindAppliesToTask,
	}, now)
	m := loadReadyModel(t, NewModel(newFakeService(
		[]domain.Project{p},
		[]domain.Column{c},
		[]domain.Task{task},
	)))
	beforeStatus := m.status
	m = applyMsg(t, m, keyRune('f'))
	if m.projectionRootTaskID != "" {
		t.Fatalf("expected focus root unchanged when selected task has no children, got %q", m.projectionRootTaskID)
	}
	if m.status != beforeStatus {
		t.Fatalf("expected status unchanged when f is no-op, before=%q after=%q", beforeStatus, m.status)
	}
	rendered := stripANSI(fmt.Sprint(m.View().Content))
	if strings.Contains(rendered, "subtree focus active") {
		t.Fatalf("expected no subtree-focus banner for no-op focus, got\n%s", rendered)
	}
}

// TestModelViewShowsHierarchyMarkers verifies branch/phase markers in card metadata rows.
func TestModelViewShowsHierarchyMarkers(t *testing.T) {
	now := time.Date(2026, 2, 25, 10, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Roadmap", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	branch, _ := domain.NewTask(domain.TaskInput{
		ID:        "b1",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Branch",
		Priority:  domain.PriorityMedium,
		Kind:      domain.WorkKind("branch"),
		Scope:     domain.KindAppliesToBranch,
	}, now)
	phase, _ := domain.NewTask(domain.TaskInput{
		ID:        "p2",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  1,
		Title:     "Phase",
		Priority:  domain.PriorityMedium,
		Kind:      domain.WorkKindPhase,
		Scope:     domain.KindAppliesToPhase,
	}, now)

	m := loadReadyModel(t, NewModel(newFakeService(
		[]domain.Project{p},
		[]domain.Column{c},
		[]domain.Task{branch, phase},
	)))
	view := stripANSI(fmt.Sprint(m.View().Content))
	if !strings.Contains(view, "[branch|medium]") {
		t.Fatalf("expected branch marker in card metadata, got\n%s", view)
	}
	if !strings.Contains(view, "[phase|medium]") {
		t.Fatalf("expected phase marker in card metadata, got\n%s", view)
	}
}

// TestModelViewShowsNoticesPanel verifies right-side notices panel rendering on wide layouts.
func TestModelViewShowsNoticesPanel(t *testing.T) {
	now := time.Date(2026, 2, 25, 11, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	todo, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	progress, _ := domain.NewColumn("c2", p.ID, "In Progress", 1, 0, now)
	done, _ := domain.NewColumn("c3", p.ID, "Done", 2, 0, now)
	blocked, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-blocked",
		ProjectID: p.ID,
		ColumnID:  todo.ID,
		Position:  0,
		Title:     "Blocked",
		Priority:  domain.PriorityHigh,
		Metadata: domain.TaskMetadata{
			BlockedReason: "waiting on approval",
			DependsOn:     []string{"missing"},
		},
	}, now)
	m := loadReadyModel(t, NewModel(newFakeService(
		[]domain.Project{p},
		[]domain.Column{todo, progress, done},
		[]domain.Task{blocked},
	)))
	rendered := stripANSI(fmt.Sprint(m.View().Content))
	if !strings.Contains(rendered, "Notices") {
		t.Fatalf("expected notices panel title, got\n%s", rendered)
	}
	if !strings.Contains(rendered, "Agent/User Action") {
		t.Fatalf("expected notices panel attention section, got\n%s", rendered)
	}
	if !strings.Contains(rendered, "g opens full activity log") {
		t.Fatalf("expected activity-log hint in notices panel, got\n%s", rendered)
	}
}

// TestModelViewShowsAttentionMarkersAndSummary verifies unresolved-attention markers and compact scope totals in board view.
func TestModelViewShowsAttentionMarkersAndSummary(t *testing.T) {
	now := time.Date(2026, 2, 24, 10, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	todo, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	progress, _ := domain.NewColumn("c2", p.ID, "In Progress", 1, 0, now)
	done, _ := domain.NewColumn("c3", p.ID, "Done", 2, 0, now)

	doneTask, _ := domain.NewTask(domain.TaskInput{
		ID:             "t-done",
		ProjectID:      p.ID,
		ColumnID:       done.ID,
		Position:       0,
		Title:          "Done Task",
		Priority:       domain.PriorityLow,
		Kind:           domain.WorkKindTask,
		Scope:          domain.KindAppliesToTask,
		LifecycleState: domain.StateDone,
	}, now)
	blockedTask, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-blocked",
		ProjectID: p.ID,
		ColumnID:  todo.ID,
		Position:  0,
		Title:     "Blocked Task",
		Priority:  domain.PriorityHigh,
		Kind:      domain.WorkKindTask,
		Scope:     domain.KindAppliesToTask,
		Metadata: domain.TaskMetadata{
			DependsOn:     []string{"t-missing"},
			BlockedReason: "waiting on partner team",
		},
	}, now)
	waitingTask, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-waiting",
		ProjectID: p.ID,
		ColumnID:  progress.ID,
		Position:  0,
		Title:     "Waiting Task",
		Priority:  domain.PriorityMedium,
		Kind:      domain.WorkKindTask,
		Scope:     domain.KindAppliesToTask,
		Metadata: domain.TaskMetadata{
			BlockedBy: []string{"t-not-found"},
		},
	}, now)

	m := loadReadyModel(t, NewModel(newFakeService(
		[]domain.Project{p},
		[]domain.Column{todo, progress, done},
		[]domain.Task{doneTask, blockedTask, waitingTask},
	)))
	rendered := stripANSI(fmt.Sprint(m.View().Content))
	if !strings.Contains(rendered, "attention: 3") {
		t.Fatalf("expected header attention count, got\n%s", rendered)
	}
	if !strings.Contains(rendered, "attention scope: 2 items  unresolved 3  blocked 1") {
		t.Fatalf("expected attention summary line, got\n%s", rendered)
	}
	if !strings.Contains(rendered, "attention panel:") {
		t.Fatalf("expected compact attention panel line, got\n%s", rendered)
	}
	if !strings.Contains(rendered, "Blocked Task !2") {
		t.Fatalf("expected row marker for blocked task, got\n%s", rendered)
	}
	if !strings.Contains(rendered, "Waiting Task !1") {
		t.Fatalf("expected row marker for waiting task, got\n%s", rendered)
	}
}

// TestSearchLevelFiltering verifies level-scoped filtering for project, branch, phase, subphase, task, and subtask.
func TestSearchLevelFiltering(t *testing.T) {
	now := time.Date(2026, 2, 24, 11, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Hierarchy", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	branch, _ := domain.NewTask(domain.TaskInput{
		ID:        "l-branch",
		ProjectID: p.ID,
		ColumnID:  c.ID,
		Position:  0,
		Title:     "Branch",
		Priority:  domain.PriorityLow,
		Kind:      domain.WorkKind("branch"),
		Scope:     domain.KindAppliesToBranch,
	}, now)
	phase, _ := domain.NewTask(domain.TaskInput{
		ID:        "l-phase",
		ProjectID: p.ID,
		ParentID:  branch.ID,
		ColumnID:  c.ID,
		Position:  1,
		Title:     "Phase",
		Priority:  domain.PriorityLow,
		Kind:      domain.WorkKindPhase,
		Scope:     domain.KindAppliesToPhase,
	}, now)
	subphase, _ := domain.NewTask(domain.TaskInput{
		ID:        "l-subphase",
		ProjectID: p.ID,
		ParentID:  phase.ID,
		ColumnID:  c.ID,
		Position:  2,
		Title:     "Subphase",
		Priority:  domain.PriorityLow,
		Kind:      domain.WorkKindPhase,
		Scope:     domain.KindAppliesToPhase,
	}, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:        "l-task",
		ProjectID: p.ID,
		ParentID:  subphase.ID,
		ColumnID:  c.ID,
		Position:  3,
		Title:     "Task",
		Priority:  domain.PriorityLow,
		Kind:      domain.WorkKindTask,
		Scope:     domain.KindAppliesToTask,
	}, now)
	subtask, _ := domain.NewTask(domain.TaskInput{
		ID:        "l-subtask",
		ProjectID: p.ID,
		ParentID:  task.ID,
		ColumnID:  c.ID,
		Position:  4,
		Title:     "Subtask",
		Priority:  domain.PriorityLow,
		Kind:      domain.WorkKindSubtask,
		Scope:     domain.KindAppliesToSubtask,
	}, now)

	m := Model{
		tasks: []domain.Task{branch, phase, subphase, task, subtask},
	}
	matches := []app.TaskMatch{
		{Project: p, Task: branch, StateID: "todo"},
		{Project: p, Task: phase, StateID: "todo"},
		{Project: p, Task: subphase, StateID: "todo"},
		{Project: p, Task: task, StateID: "todo"},
		{Project: p, Task: subtask, StateID: "todo"},
	}
	ids := func(in []app.TaskMatch) string {
		out := make([]string, 0, len(in))
		for _, match := range in {
			out = append(out, match.Task.ID)
		}
		return strings.Join(out, ",")
	}

	cases := []struct {
		name   string
		levels []string
		want   string
	}{
		{name: "project", levels: []string{"project"}, want: "l-branch,l-phase,l-subphase,l-task,l-subtask"},
		{name: "branch", levels: []string{"branch"}, want: "l-branch"},
		{name: "phase", levels: []string{"phase"}, want: "l-phase"},
		{name: "subphase", levels: []string{"subphase"}, want: "l-subphase"},
		{name: "task", levels: []string{"task"}, want: "l-task"},
		{name: "subtask", levels: []string{"subtask"}, want: "l-subtask"},
	}
	for _, tc := range cases {
		m.searchLevels = tc.levels
		got := ids(m.filterTaskMatchesBySearchLevels(matches))
		if got != tc.want {
			t.Fatalf("%s level filter mismatch: want %q, got %q", tc.name, tc.want, got)
		}
	}

	ready := loadReadyModel(t, NewModel(newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{branch, phase, subphase, task, subtask})))
	ready = applyMsg(t, ready, keyRune('/'))
	ready = applyMsg(t, ready, tea.KeyPressMsg{Code: tea.KeyTab}) // states
	ready = applyMsg(t, ready, tea.KeyPressMsg{Code: tea.KeyTab}) // levels
	if ready.searchFocus != 2 {
		t.Fatalf("expected levels focus slot in search modal, got %d", ready.searchFocus)
	}
	if !ready.isSearchLevelEnabled("project") {
		t.Fatalf("expected project level enabled by default, got %#v", ready.searchLevels)
	}
	ready = applyMsg(t, ready, keyRune(' '))
	if ready.isSearchLevelEnabled("project") {
		t.Fatalf("expected project level toggle to disable via level-scoped controls, got %#v", ready.searchLevels)
	}
}

// TestModelDependencyRollupAndTaskInfoHints verifies rollup summary and task dependency hints.
func TestModelDependencyRollupAndTaskInfoHints(t *testing.T) {
	now := time.Date(2026, 2, 21, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	done, _ := domain.NewTask(domain.TaskInput{
		ID:             "t-done",
		ProjectID:      p.ID,
		ColumnID:       c.ID,
		Position:       0,
		Title:          "Finished",
		Priority:       domain.PriorityLow,
		LifecycleState: domain.StateDone,
	}, now)
	blocked, _ := domain.NewTask(domain.TaskInput{
		ID:             "t-blocked",
		ProjectID:      p.ID,
		ColumnID:       c.ID,
		Position:       1,
		Title:          "Blocked",
		Priority:       domain.PriorityHigh,
		LifecycleState: domain.StateTodo,
		Metadata: domain.TaskMetadata{
			DependsOn:     []string{"t-done", "t-missing"},
			BlockedBy:     []string{"t-done"},
			BlockedReason: "waiting on integration",
		},
	}, now)
	svc := newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{done, blocked})
	m := loadReadyModel(t, NewModel(svc))

	if summary := m.dependencyRollupSummary(); !strings.Contains(summary, "total 2") || !strings.Contains(summary, "blocked 1") || !strings.Contains(summary, "unresolved 1") {
		t.Fatalf("expected dependency rollup summary counts, got %q", summary)
	}

	m = applyMsg(t, m, keyRune('j'))
	m = applyMsg(t, m, keyRune('i'))
	info := m.renderModeOverlay(lipgloss.Color("62"), lipgloss.Color("241"), lipgloss.Color("239"), lipgloss.NewStyle(), 96)
	if !strings.Contains(info, "depends_on: t-done(Finished)") {
		t.Fatalf("expected depends_on hints in task info, got %q", info)
	}
	if !strings.Contains(info, "blocked_by: t-done(Finished)") {
		t.Fatalf("expected blocked_by hints in task info, got %q", info)
	}
	if !strings.Contains(info, "blocked_reason: waiting on integration") {
		t.Fatalf("expected blocked_reason hint in task info, got %q", info)
	}
}

// TestModelDependencyInspectorPinsLinkedRefsAndAppliesEdits verifies dependency inspector linked-row pinning and task-info save/jump flows.
func TestModelDependencyInspectorPinsLinkedRefsAndAppliesEdits(t *testing.T) {
	now := time.Date(2026, 2, 23, 9, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	cTodo, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	cProgress, _ := domain.NewColumn("c2", p.ID, "In Progress", 1, 0, now)
	cDone, _ := domain.NewColumn("c3", p.ID, "Done", 2, 0, now)

	owner, _ := domain.NewTask(domain.TaskInput{
		ID:             "t-owner",
		ProjectID:      p.ID,
		ColumnID:       cTodo.ID,
		Position:       0,
		Title:          "Owner",
		Priority:       domain.PriorityMedium,
		LifecycleState: domain.StateTodo,
	}, now)
	depDone, _ := domain.NewTask(domain.TaskInput{
		ID:             "t-done",
		ProjectID:      p.ID,
		ColumnID:       cDone.ID,
		Position:       0,
		Title:          "Done dependency",
		Priority:       domain.PriorityLow,
		LifecycleState: domain.StateDone,
	}, now.Add(time.Minute))
	depArchived, _ := domain.NewTask(domain.TaskInput{
		ID:             "t-archived",
		ProjectID:      p.ID,
		ColumnID:       cDone.ID,
		Position:       1,
		Title:          "Archived dependency",
		Priority:       domain.PriorityLow,
		LifecycleState: domain.StateArchived,
	}, now.Add(2*time.Minute))
	archivedAt := now.Add(-time.Minute)
	depArchived.ArchivedAt = &archivedAt
	blocker, _ := domain.NewTask(domain.TaskInput{
		ID:             "t-blocker",
		ProjectID:      p.ID,
		ColumnID:       cProgress.ID,
		Position:       0,
		Title:          "Active blocker",
		Priority:       domain.PriorityHigh,
		LifecycleState: domain.StateProgress,
	}, now.Add(3*time.Minute))
	candidate, _ := domain.NewTask(domain.TaskInput{
		ID:             "t-candidate",
		ProjectID:      p.ID,
		ColumnID:       cTodo.ID,
		Position:       1,
		Title:          "Candidate dependency",
		Priority:       domain.PriorityLow,
		LifecycleState: domain.StateTodo,
	}, now.Add(4*time.Minute))

	owner.Metadata = domain.TaskMetadata{
		DependsOn: []string{owner.ID, depDone.ID, depArchived.ID},
		BlockedBy: []string{blocker.ID},
	}

	svc := newFakeService(
		[]domain.Project{p},
		[]domain.Column{cTodo, cProgress, cDone},
		[]domain.Task{owner, depDone, depArchived, blocker, candidate},
	)
	m := loadReadyModel(t, NewModel(svc))

	m = applyMsg(t, m, keyRune('i'))
	m = applyMsg(t, m, keyRune('b'))
	m = applyMsg(t, m, m.loadDependencyMatches())
	if m.mode != modeDependencyInspector {
		t.Fatalf("expected dependency inspector mode, got %v", m.mode)
	}
	if len(m.dependencyMatches) < 3 {
		t.Fatalf("expected linked rows loaded, got %d", len(m.dependencyMatches))
	}
	if idx := dependencyCandidateIndexByID(m.dependencyMatches, owner.ID); idx >= 0 {
		t.Fatalf("expected owner task %q to be excluded from dependency candidates", owner.ID)
	}
	if got := m.dependencyMatches[0].Match.Task.ID; got != depDone.ID {
		t.Fatalf("expected first pinned row %q, got %q", depDone.ID, got)
	}
	if got := m.dependencyMatches[1].Match.Task.ID; got != depArchived.ID {
		t.Fatalf("expected second pinned row %q, got %q", depArchived.ID, got)
	}
	if got := m.dependencyMatches[2].Match.Task.ID; got != blocker.ID {
		t.Fatalf("expected third pinned row %q, got %q", blocker.ID, got)
	}

	foundArchived := false
	for _, candidateRow := range m.dependencyMatches {
		if candidateRow.Match.Task.ID == depArchived.ID {
			foundArchived = true
			break
		}
	}
	if !foundArchived {
		t.Fatal("expected linked archived dependency to remain visible in inspector list")
	}

	for i := 0; i < 4; i++ {
		m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyTab})
	}
	if m.dependencyFocus != 4 {
		t.Fatalf("expected list focus, got %d", m.dependencyFocus)
	}
	addIdx := dependencyCandidateIndexByID(m.dependencyMatches, candidate.ID)
	if addIdx < 0 {
		t.Fatalf("expected candidate row %q", candidate.ID)
	}
	m.dependencyIndex = addIdx
	m = applyMsg(t, m, keyRune('d'))
	m = applyMsg(t, m, keyRune('a'))
	if m.mode != modeTaskInfo {
		t.Fatalf("expected return to task-info after apply, got %v", m.mode)
	}
	ownerAfter, ok := m.taskByID(owner.ID)
	if !ok {
		t.Fatalf("expected owner task %q after apply", owner.ID)
	}
	if !hasDependencyID(ownerAfter.Metadata.DependsOn, candidate.ID) {
		t.Fatalf("expected candidate dependency %q saved, got %#v", candidate.ID, ownerAfter.Metadata.DependsOn)
	}
	if hasDependencyID(ownerAfter.Metadata.DependsOn, owner.ID) {
		t.Fatalf("expected self dependency %q to be stripped on save, got %#v", owner.ID, ownerAfter.Metadata.DependsOn)
	}

	m = applyMsg(t, m, keyRune('b'))
	m = applyMsg(t, m, m.loadDependencyMatches())
	for i := 0; i < 4; i++ {
		m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyTab})
	}
	jumpIdx := dependencyCandidateIndexByID(m.dependencyMatches, blocker.ID)
	if jumpIdx < 0 {
		t.Fatalf("expected blocker row %q for jump", blocker.ID)
	}
	m.dependencyIndex = jumpIdx
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if m.mode != modeTaskInfo {
		t.Fatalf("expected task-info mode after dependency jump, got %v", m.mode)
	}
	if m.taskInfoTaskID != blocker.ID {
		t.Fatalf("expected jump to blocker %q, got %q", blocker.ID, m.taskInfoTaskID)
	}
}

// TestModelDependencyInspectorCtrlOFromTaskForm verifies task-form dependency picker opens with ctrl+o and applies CSV field updates.
func TestModelDependencyInspectorCtrlOFromTaskForm(t *testing.T) {
	now := time.Date(2026, 2, 23, 11, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	owner, _ := domain.NewTask(domain.TaskInput{
		ID:             "t-owner",
		ProjectID:      p.ID,
		ColumnID:       c.ID,
		Position:       0,
		Title:          "Owner",
		Priority:       domain.PriorityMedium,
		LifecycleState: domain.StateTodo,
	}, now)
	candidate, _ := domain.NewTask(domain.TaskInput{
		ID:             "t-candidate",
		ProjectID:      p.ID,
		ColumnID:       c.ID,
		Position:       1,
		Title:          "Candidate",
		Priority:       domain.PriorityLow,
		LifecycleState: domain.StateTodo,
	}, now.Add(time.Minute))

	m := loadReadyModel(t, NewModel(newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{owner, candidate})))
	m = applyMsg(t, m, keyRune('e'))
	if m.mode != modeEditTask {
		t.Fatalf("expected edit-task mode, got %v", m.mode)
	}
	m = applyCmd(t, m, m.focusTaskFormField(taskFieldDependsOn))
	m = applyMsg(t, m, tea.KeyPressMsg{Code: 'o', Mod: tea.ModCtrl})
	m = applyMsg(t, m, m.loadDependencyMatches())
	if m.mode != modeDependencyInspector {
		t.Fatalf("expected dependency inspector from ctrl+o, got %v", m.mode)
	}

	for i := 0; i < 4; i++ {
		m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyTab})
	}
	addIdx := dependencyCandidateIndexByID(m.dependencyMatches, candidate.ID)
	if addIdx < 0 {
		t.Fatalf("expected candidate row %q", candidate.ID)
	}
	m.dependencyIndex = addIdx
	m = applyMsg(t, m, keyRune('d'))
	m = applyMsg(t, m, keyRune('a'))
	if m.mode != modeEditTask {
		t.Fatalf("expected return to edit-task mode after apply, got %v", m.mode)
	}
	if got := m.formInputs[taskFieldDependsOn].Value(); got != candidate.ID {
		t.Fatalf("expected depends_on CSV %q, got %q", candidate.ID, got)
	}
}

// TestModelDependencyInspectorOverlayRendersMissingLinkedRefs verifies missing linked references stay inspectable in the dependency modal.
func TestModelDependencyInspectorOverlayRendersMissingLinkedRefs(t *testing.T) {
	now := time.Date(2026, 2, 23, 12, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	owner, _ := domain.NewTask(domain.TaskInput{
		ID:             "t-owner",
		ProjectID:      p.ID,
		ColumnID:       c.ID,
		Position:       0,
		Title:          "Owner",
		Priority:       domain.PriorityMedium,
		LifecycleState: domain.StateTodo,
	}, now)
	blocker, _ := domain.NewTask(domain.TaskInput{
		ID:             "t-blocker",
		ProjectID:      p.ID,
		ColumnID:       c.ID,
		Position:       1,
		Title:          "Blocker",
		Priority:       domain.PriorityLow,
		LifecycleState: domain.StateTodo,
	}, now.Add(time.Minute))
	owner.Metadata = domain.TaskMetadata{
		DependsOn: []string{"t-missing"},
		BlockedBy: []string{blocker.ID},
	}

	m := loadReadyModel(t, NewModel(newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{owner, blocker})))
	m = applyMsg(t, m, keyRune('i'))
	m = applyMsg(t, m, keyRune('b'))
	m = applyMsg(t, m, m.loadDependencyMatches())
	if m.mode != modeDependencyInspector {
		t.Fatalf("expected dependency inspector mode, got %v", m.mode)
	}

	out := stripANSI(m.renderModeOverlay(
		lipgloss.Color("62"),
		lipgloss.Color("241"),
		lipgloss.Color("239"),
		lipgloss.NewStyle(),
		96,
	))
	if !strings.Contains(out, "linked refs are pinned at top") {
		t.Fatalf("expected pinned-linked hint, got %q", out)
	}
	if !strings.Contains(out, "(missing task reference)") {
		t.Fatalf("expected missing reference row, got %q", out)
	}
	if !strings.Contains(out, "state: missing") {
		t.Fatalf("expected missing reference details state, got %q", out)
	}
}

// TestModelDependencyInspectorFormEnterDoesNotJump verifies enter-jump is blocked when opened from task form context.
func TestModelDependencyInspectorFormEnterDoesNotJump(t *testing.T) {
	now := time.Date(2026, 2, 23, 13, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	owner, _ := domain.NewTask(domain.TaskInput{
		ID:             "t-owner",
		ProjectID:      p.ID,
		ColumnID:       c.ID,
		Position:       0,
		Title:          "Owner",
		Priority:       domain.PriorityMedium,
		LifecycleState: domain.StateTodo,
	}, now)
	candidate, _ := domain.NewTask(domain.TaskInput{
		ID:             "t-candidate",
		ProjectID:      p.ID,
		ColumnID:       c.ID,
		Position:       1,
		Title:          "Candidate",
		Priority:       domain.PriorityLow,
		LifecycleState: domain.StateTodo,
	}, now.Add(time.Minute))

	m := loadReadyModel(t, NewModel(newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{owner, candidate})))
	m = applyMsg(t, m, keyRune('e'))
	m = applyCmd(t, m, m.focusTaskFormField(taskFieldDependsOn))
	m = applyMsg(t, m, tea.KeyPressMsg{Code: 'o', Mod: tea.ModCtrl})
	m = applyMsg(t, m, m.loadDependencyMatches())
	if m.mode != modeDependencyInspector {
		t.Fatalf("expected dependency inspector mode, got %v", m.mode)
	}
	for i := 0; i < 4; i++ {
		m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyTab})
	}
	m.dependencyIndex = dependencyCandidateIndexByID(m.dependencyMatches, candidate.ID)
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if m.mode != modeDependencyInspector {
		t.Fatalf("expected dependency inspector to stay open on enter from form mode, got %v", m.mode)
	}
	if !strings.Contains(m.status, "task-info inspector") {
		t.Fatalf("expected non-task-info jump status, got %q", m.status)
	}
}

// TestDependencyStateIDForTask verifies fallback state-id derivation for dependency rows.
func TestDependencyStateIDForTask(t *testing.T) {
	now := time.Date(2026, 2, 23, 14, 0, 0, 0, time.UTC)
	archivedAt := now.Add(-time.Minute)
	taskArchived := domain.Task{LifecycleState: domain.StateDone, ArchivedAt: &archivedAt}
	taskProgress := domain.Task{LifecycleState: domain.StateProgress}
	taskUnknown := domain.Task{LifecycleState: domain.LifecycleState("review")}
	taskEmpty := domain.Task{}

	if got := dependencyStateIDForTask(taskArchived); got != "archived" {
		t.Fatalf("expected archived state id, got %q", got)
	}
	if got := dependencyStateIDForTask(taskProgress); got != "progress" {
		t.Fatalf("expected progress state id, got %q", got)
	}
	if got := dependencyStateIDForTask(taskUnknown); got != "review" {
		t.Fatalf("expected custom normalized state id, got %q", got)
	}
	if got := dependencyStateIDForTask(taskEmpty); got != "todo" {
		t.Fatalf("expected todo fallback state id, got %q", got)
	}
}

// TestModelDependencyInspectorFilterControls verifies dependency inspector control paths for query/filter toggles and cancel flow.
func TestModelDependencyInspectorFilterControls(t *testing.T) {
	now := time.Date(2026, 2, 23, 15, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	owner, _ := domain.NewTask(domain.TaskInput{
		ID:             "t-owner",
		ProjectID:      p.ID,
		ColumnID:       c.ID,
		Position:       0,
		Title:          "Owner",
		Priority:       domain.PriorityMedium,
		LifecycleState: domain.StateTodo,
	}, now)
	candidate, _ := domain.NewTask(domain.TaskInput{
		ID:             "t-candidate",
		ProjectID:      p.ID,
		ColumnID:       c.ID,
		Position:       1,
		Title:          "Candidate",
		Priority:       domain.PriorityLow,
		LifecycleState: domain.StateTodo,
	}, now.Add(time.Minute))
	owner.Metadata = domain.TaskMetadata{DependsOn: []string{candidate.ID}}

	m := loadReadyModel(t, NewModel(newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{owner, candidate})))
	m = applyMsg(t, m, keyRune('i'))
	m = applyMsg(t, m, keyRune('b'))
	m = applyMsg(t, m, m.loadDependencyMatches())
	if m.mode != modeDependencyInspector {
		t.Fatalf("expected dependency inspector mode, got %v", m.mode)
	}

	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyTab}) // states focus
	m = applyMsg(t, m, keyRune('x'))
	if m.dependencyActiveField != taskFieldBlockedBy {
		t.Fatalf("expected active field switch to blocked_by, got %d", m.dependencyActiveField)
	}
	m = applyMsg(t, m, keyRune('k')) // query focus
	for _, r := range []rune("qq") {
		m = applyMsg(t, m, keyRune(r))
	}
	if got := strings.TrimSpace(m.dependencyInput.Value()); got != "qq" {
		t.Fatalf("expected typed dependency query, got %q", got)
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: 'u', Mod: tea.ModCtrl})
	if got := strings.TrimSpace(m.dependencyInput.Value()); got != "" {
		t.Fatalf("expected ctrl+u to clear dependency query, got %q", got)
	}

	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyTab}) // states focus
	m = applyMsg(t, m, keyRune(' '))
	if m.isDependencyStateEnabled("todo") {
		t.Fatalf("expected todo state disabled after toggle, got %#v", m.dependencyStates)
	}
	m = applyMsg(t, m, keyRune(' '))
	if !m.isDependencyStateEnabled("todo") {
		t.Fatalf("expected todo state restored for list actions, got %#v", m.dependencyStates)
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyTab}) // scope focus
	beforeScope := m.dependencyCrossProject
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if m.dependencyCrossProject == beforeScope {
		t.Fatalf("expected scope toggle, got %t", m.dependencyCrossProject)
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyTab}) // archived focus
	beforeArchived := m.dependencyIncludeArchived
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEnter})
	if m.dependencyIncludeArchived == beforeArchived {
		t.Fatalf("expected archived toggle, got %t", m.dependencyIncludeArchived)
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyTab}) // list focus
	if m.dependencyFocus != 4 {
		t.Fatalf("expected list focus, got %d", m.dependencyFocus)
	}
	if m.dependencyActiveField != taskFieldBlockedBy {
		t.Fatalf("expected blocked_by active field before list toggle, got %d", m.dependencyActiveField)
	}
	m = applyMsg(t, m, keyRune(' '))
	if !hasDependencyID(m.dependencyBlockedBy, candidate.ID) {
		t.Fatalf("expected space-toggle add into active blocked_by field, got %#v", m.dependencyBlockedBy)
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: 'r', Mod: tea.ModCtrl})
	if m.dependencyCrossProject != m.searchDefaultCrossProject {
		t.Fatalf("expected ctrl+r reset scope to default, got %t", m.dependencyCrossProject)
	}
	if m.dependencyIncludeArchived != m.searchDefaultIncludeArchive {
		t.Fatalf("expected ctrl+r reset archived flag, got %t", m.dependencyIncludeArchived)
	}

	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyEscape})
	if m.mode != modeTaskInfo {
		t.Fatalf("expected esc to return task-info mode, got %v", m.mode)
	}
}

// TestModelDependencyInspectorInputAndListKeyRouting verifies that query input keeps text keys while list actions stay list-scoped.
func TestModelDependencyInspectorInputAndListKeyRouting(t *testing.T) {
	now := time.Date(2026, 2, 23, 16, 0, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	owner, _ := domain.NewTask(domain.TaskInput{
		ID:             "t-owner",
		ProjectID:      p.ID,
		ColumnID:       c.ID,
		Position:       0,
		Title:          "Owner",
		Priority:       domain.PriorityMedium,
		LifecycleState: domain.StateTodo,
	}, now)
	candidate, _ := domain.NewTask(domain.TaskInput{
		ID:             "t-candidate",
		ProjectID:      p.ID,
		ColumnID:       c.ID,
		Position:       1,
		Title:          "Candidate",
		Priority:       domain.PriorityLow,
		LifecycleState: domain.StateTodo,
	}, now.Add(time.Minute))

	m := loadReadyModel(t, NewModel(newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{owner, candidate})))
	m = applyMsg(t, m, keyRune('i'))
	m = applyMsg(t, m, keyRune('b'))
	m = applyMsg(t, m, m.loadDependencyMatches())
	if m.mode != modeDependencyInspector {
		t.Fatalf("expected dependency inspector mode, got %v", m.mode)
	}
	if m.dependencyFocus != 0 {
		t.Fatalf("expected query focus, got %d", m.dependencyFocus)
	}
	initialField := m.dependencyActiveField

	m = applyMsg(t, m, keyRune('x'))
	m = applyMsg(t, m, keyRune('a'))
	m = applyMsg(t, m, keyRune('d'))
	if got := m.dependencyInput.Value(); got != "xad" {
		t.Fatalf("expected action keys to type in query input, got %q", got)
	}
	if m.dependencyActiveField != initialField {
		t.Fatalf("expected active field unchanged while typing query, got %d", m.dependencyActiveField)
	}
	if len(m.dependencyDependsOn) != 0 || len(m.dependencyBlockedBy) != 0 {
		t.Fatalf("expected no dependency toggles while query focused, got depends=%#v blocked=%#v", m.dependencyDependsOn, m.dependencyBlockedBy)
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: 'u', Mod: tea.ModCtrl})
	if got := m.dependencyInput.Value(); got != "" {
		t.Fatalf("expected ctrl+u to clear query before list assertions, got %q", got)
	}

	m = applyMsg(t, m, keyRune('j'))
	if m.dependencyFocus != 1 {
		t.Fatalf("expected j to move focus from query to states, got %d", m.dependencyFocus)
	}
	m = applyMsg(t, m, keyRune('d'))
	m = applyMsg(t, m, keyRune('b'))
	if len(m.dependencyDependsOn) != 0 || len(m.dependencyBlockedBy) != 0 {
		t.Fatalf("expected d/b to be ignored outside list focus, got depends=%#v blocked=%#v", m.dependencyDependsOn, m.dependencyBlockedBy)
	}

	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyDown})
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyDown})
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyDown})
	if m.dependencyFocus != 4 {
		t.Fatalf("expected down navigation to reach list focus, got %d", m.dependencyFocus)
	}
	idx := dependencyCandidateIndexByID(m.dependencyMatches, candidate.ID)
	if idx < 0 {
		t.Fatalf("expected candidate row %q", candidate.ID)
	}
	m.dependencyIndex = idx
	m = applyMsg(t, m, keyRune('d'))
	m = applyMsg(t, m, keyRune('b'))
	if !hasDependencyID(m.dependencyDependsOn, candidate.ID) {
		t.Fatalf("expected list-focused d to toggle depends_on, got %#v", m.dependencyDependsOn)
	}
	if !hasDependencyID(m.dependencyBlockedBy, candidate.ID) {
		t.Fatalf("expected list-focused b to toggle blocked_by, got %#v", m.dependencyBlockedBy)
	}
}

// TestModelSearchFocusNavigationWithJK verifies query typing and focus navigation in the search modal.
func TestModelSearchFocusNavigationWithJK(t *testing.T) {
	now := time.Date(2026, 2, 23, 16, 30, 0, 0, time.UTC)
	p, _ := domain.NewProject("p1", "Inbox", "", now)
	c, _ := domain.NewColumn("c1", p.ID, "To Do", 0, 0, now)
	task, _ := domain.NewTask(domain.TaskInput{
		ID:             "t1",
		ProjectID:      p.ID,
		ColumnID:       c.ID,
		Position:       0,
		Title:          "Task",
		Priority:       domain.PriorityLow,
		LifecycleState: domain.StateTodo,
	}, now)

	m := loadReadyModel(t, NewModel(newFakeService([]domain.Project{p}, []domain.Column{c}, []domain.Task{task})))
	m = applyMsg(t, m, keyRune('/'))
	if m.mode != modeSearch {
		t.Fatalf("expected search mode, got %v", m.mode)
	}
	if m.searchFocus != 0 {
		t.Fatalf("expected initial search focus on query, got %d", m.searchFocus)
	}

	m = applyMsg(t, m, keyRune('j'))
	if m.searchFocus != 0 {
		t.Fatalf("expected query focus to remain active while typing j, got %d", m.searchFocus)
	}
	if got := m.searchInput.Value(); got != "j" {
		t.Fatalf("expected j to type in query input, got %q", got)
	}

	m = applyMsg(t, m, keyRune('k'))
	if m.searchFocus != 0 {
		t.Fatalf("expected query focus to remain active while typing k, got %d", m.searchFocus)
	}
	if got := m.searchInput.Value(); got != "jk" {
		t.Fatalf("expected k to type in query input, got %q", got)
	}

	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyDown})
	if m.searchFocus != 1 {
		t.Fatalf("expected down arrow to move search focus forward, got %d", m.searchFocus)
	}
	m = applyMsg(t, m, tea.KeyPressMsg{Code: tea.KeyUp})
	if m.searchFocus != 0 {
		t.Fatalf("expected up arrow to move search focus backward, got %d", m.searchFocus)
	}
}

// TestSortTaskSlicePrefersCreationTime verifies oldest-first ordering regardless of move position churn.
func TestSortTaskSlicePrefersCreationTime(t *testing.T) {
	now := time.Date(2026, 2, 22, 12, 0, 0, 0, time.UTC)
	older, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-older",
		ProjectID: "p1",
		ColumnID:  "c1",
		Position:  9,
		Title:     "Older",
		Priority:  domain.PriorityLow,
	}, now)
	newer, _ := domain.NewTask(domain.TaskInput{
		ID:        "t-newer",
		ProjectID: "p1",
		ColumnID:  "c1",
		Position:  0,
		Title:     "Newer",
		Priority:  domain.PriorityLow,
	}, now.Add(time.Minute))

	tasks := []domain.Task{newer, older}
	sortTaskSlice(tasks)
	if tasks[0].ID != older.ID {
		t.Fatalf("expected oldest task first, got %#v", tasks)
	}
}

// dependencyCandidateIndexByID finds one dependency-candidate index by task id.
func dependencyCandidateIndexByID(candidates []dependencyCandidate, taskID string) int {
	taskID = strings.TrimSpace(taskID)
	if taskID == "" {
		return -1
	}
	for idx, candidate := range candidates {
		if strings.TrimSpace(candidate.Match.Task.ID) == taskID {
			return idx
		}
	}
	return -1
}

// ansiEscapePattern matches terminal color/style escape sequences for text assertions.
var ansiEscapePattern = regexp.MustCompile(`\x1b\[[0-9;]*m`)

// stripANSI removes ANSI control codes from rendered output.
func stripANSI(in string) string {
	return ansiEscapePattern.ReplaceAllString(in, "")
}

// applyResult applies a model+command result tuple.
func applyResult(t *testing.T, updated tea.Model, cmd tea.Cmd) Model {
	t.Helper()
	out, ok := updated.(Model)
	if !ok {
		t.Fatalf("expected Model, got %T", updated)
	}
	return applyCmd(t, out, cmd)
}

// loadReadyModel loads data and accepts the initial launch picker when projects already exist.
func loadReadyModel(t *testing.T, m Model) Model {
	t.Helper()
	ready := applyMsg(t, applyCmd(t, m, m.Init()), tea.WindowSizeMsg{Width: 120, Height: 40})
	if ready.mode == modeProjectPicker && len(ready.projects) > 0 {
		ready = applyMsg(t, ready, tea.KeyPressMsg{Code: tea.KeyEnter})
	}
	return ready
}

// applyMsg applies msg.
func applyMsg(t *testing.T, m Model, msg tea.Msg) Model {
	t.Helper()
	updated, cmd := m.Update(msg)
	out, ok := updated.(Model)
	if !ok {
		t.Fatalf("expected Model, got %T", updated)
	}
	return applyCmd(t, out, cmd)
}

// applyCmd applies cmd.
func applyCmd(t *testing.T, m Model, cmd tea.Cmd) Model {
	t.Helper()
	out := m
	currentCmd := cmd
	for i := 0; i < 6 && currentCmd != nil; i++ {
		msg := currentCmd()
		updated, nextCmd := out.Update(msg)
		casted, ok := updated.(Model)
		if !ok {
			t.Fatalf("expected Model, got %T", updated)
		}
		out = casted
		currentCmd = nextCmd
	}
	return out
}

// keyRune handles key rune.
func keyRune(r rune) tea.KeyPressMsg {
	return tea.KeyPressMsg{Code: r, Text: string(r)}
}

// TestNormalizeAttachmentPathWithinRoot verifies root-bound attachment validation behavior.
func TestNormalizeAttachmentPathWithinRoot(t *testing.T) {
	root := t.TempDir()
	inside := filepath.Join(root, "docs", "readme.md")
	if err := os.MkdirAll(filepath.Dir(inside), 0o755); err != nil {
		t.Fatalf("MkdirAll() error = %v", err)
	}
	if err := os.WriteFile(inside, []byte("ok"), 0o644); err != nil {
		t.Fatalf("WriteFile() error = %v", err)
	}

	outsideDir := t.TempDir()
	outside := filepath.Join(outsideDir, "outside.md")
	if err := os.WriteFile(outside, []byte("bad"), 0o644); err != nil {
		t.Fatalf("WriteFile(outside) error = %v", err)
	}

	normalizedInside, err := normalizeAttachmentPathWithinRoot(root, inside)
	if err != nil {
		t.Fatalf("normalizeAttachmentPathWithinRoot(inside) error = %v", err)
	}
	if filepath.Clean(normalizedInside) != filepath.Clean(inside) {
		t.Fatalf("expected normalized inside path %q, got %q", inside, normalizedInside)
	}

	if _, err := normalizeAttachmentPathWithinRoot(root, outside); err == nil {
		t.Fatal("expected outside-root path to be rejected")
	}
	if _, err := normalizeAttachmentPathWithinRoot("", inside); err == nil {
		t.Fatal("expected empty-root attachment normalization to fail")
	}
	rootFile := filepath.Join(t.TempDir(), "root.txt")
	if err := os.WriteFile(rootFile, []byte("root"), 0o644); err != nil {
		t.Fatalf("WriteFile(rootFile) error = %v", err)
	}
	if _, err := normalizeAttachmentPathWithinRoot(rootFile, inside); err == nil {
		t.Fatal("expected non-directory root to be rejected")
	}
}
